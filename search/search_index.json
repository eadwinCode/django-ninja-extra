{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":""},{"location":"#django-ninja-extra","title":"Django Ninja Extra","text":"<p>Django Ninja Extra is a powerful extension for Django Ninja that enhances your Django REST API development experience. It introduces class-based views and advanced features while maintaining the high performance and simplicity of Django Ninja. Whether you're building a small API or a large-scale application, Django Ninja Extra provides the tools you need for clean, maintainable, and efficient API development.</p>"},{"location":"#features","title":"Features","text":""},{"location":"#core-features-inherited-from-django-ninja","title":"Core Features (Inherited from Django Ninja)","text":"<ul> <li>\u26a1 High Performance: Built on Pydantic for lightning-fast validation</li> <li>\ud83d\udd04 Async Support: First-class support for async/await operations</li> <li>\ud83d\udcdd Type Safety: Comprehensive type hints for better development experience</li> <li>\ud83c\udfaf Django Integration: Seamless integration with Django's ecosystem</li> <li>\ud83d\udcda OpenAPI Support: Automatic API documentation with Swagger/ReDoc</li> <li>\ud83d\udd12 API Throttling: Rate limiting for your API</li> </ul>"},{"location":"#extra-features","title":"Extra Features","text":"<ul> <li>\ud83c\udfd7\ufe0f Class-Based Controllers: </li> <li>Organize related endpoints in controller classes</li> <li>Inherit common functionality</li> <li> <p>Share dependencies across endpoints</p> </li> <li> <p>\ud83d\udd12 Advanced Permission System (Similar to Django Rest Framework):</p> </li> <li>Controller-level permissions</li> <li>Route-level permission overrides</li> <li> <p>Custom permission classes</p> </li> <li> <p>\ud83d\udc89 Dependency Injection:</p> </li> <li>Built-in support for Injector</li> <li>Compatible with django_injector</li> <li> <p>Automatic dependency resolution</p> </li> <li> <p>\ud83d\udd27 Service Layer:</p> </li> <li>Injectable services for business logic</li> <li>Better separation of concerns</li> <li>Reusable components</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python &gt;= 3.6</li> <li>Django &gt;= 2.1</li> <li>Pydantic &gt;= 1.6</li> <li>Django-Ninja &gt;= 0.16.1</li> </ul>"},{"location":"#installation","title":"Installation","text":"<ol> <li> <p>Install the package: <pre><code>pip install django-ninja-extra\n</code></pre></p> </li> <li> <p>Add to INSTALLED_APPS: <pre><code>INSTALLED_APPS = [\n    ...,\n    'ninja_extra',\n]\n</code></pre></p> </li> </ol>"},{"location":"#quick-start-guide","title":"Quick Start Guide","text":""},{"location":"#1-basic-api-setup","title":"1. Basic API Setup","text":"<p>Create <code>api.py</code> in your Django project:</p> <pre><code>from ninja_extra import NinjaExtraAPI, api_controller, http_get\n\napi = NinjaExtraAPI()\n\n# Function-based endpoint example\n@api.get(\"/hello\", tags=['Basic'])\ndef hello(request, name: str = \"World\"):\n    return {\"message\": f\"Hello, {name}!\"}\n\n\n# Class-based controller example\n@api_controller('/math', tags=['Math'])\nclass MathController:\n    @http_get('/add')\n    def add(self, a: int, b: int):\n        \"\"\"Add two numbers\"\"\"\n        return {\"result\": a + b}\n\n    @http_get('/multiply')\n    def multiply(self, a: int, b: int):\n        \"\"\"Multiply two numbers\"\"\"\n        return {\"result\": a * b}\n\n# Register your controllers\napi.register_controllers(MathController)\n</code></pre>"},{"location":"#2-url-configuration","title":"2. URL Configuration","text":"<p>In <code>urls.py</code>: <pre><code>from django.urls import path\nfrom .api import api\n\nurlpatterns = [\n    path(\"api/\", api.urls),  # This will mount your API at /api/\n]\n</code></pre></p>"},{"location":"#advanced-features","title":"Advanced Features","text":""},{"location":"#authentication-and-permissions","title":"Authentication and Permissions","text":"<pre><code>from ninja_extra import api_controller, http_get\nfrom ninja_extra.permissions import IsAuthenticated, PermissionBase\n\n# Custom permission\nclass IsAdmin(PermissionBase):\n    def has_permission(self, context):\n        return context.request.user.is_staff\n\n@api_controller('/admin', tags=['Admin'], permissions=[IsAuthenticated, IsAdmin])\nclass AdminController:\n    @http_get('/stats')\n    def get_stats(self):\n        return {\"status\": \"admin only data\"}\n\n    @http_get('/public', permissions=[])  # Override to make public\n    def public_stats(self):\n        return {\"status\": \"public data\"}\n</code></pre>"},{"location":"#dependency-injection-with-services","title":"Dependency Injection with Services","text":"<pre><code>from injector import inject\nfrom ninja_extra import api_controller, http_get\n\n\n# Service class\nclass UserService:\n    def get_user_details(self, user_id: int):\n        return {\"user_id\": user_id, \"status\": \"active\"}\n\n\n# Controller with dependency injection\n@api_controller('/users', tags=['Users'])\nclass UserController:\n    def __init__(self, user_service: UserService):\n        self.user_service = user_service\n\n    @http_get('/{user_id}')\n    def get_user(self, user_id: int):\n        return self.user_service.get_user_details(user_id)\n</code></pre>"},{"location":"#api-documentation","title":"API Documentation","text":"<p>Access your API's interactive documentation at <code>/api/docs</code>:</p> <p></p>"},{"location":"#learning-resources","title":"Learning Resources","text":""},{"location":"#tutorials","title":"Tutorials","text":"<ul> <li>\ud83d\udcfa Video: Permissions &amp; Controllers</li> <li>\ud83d\udcbb Example: BookStore API</li> <li>\ud83d\udcda Official Documentation</li> </ul>"},{"location":"#community-and-support","title":"Community and Support","text":"<ul> <li>\ud83c\udf1f GitHub Repository</li> <li>\ud83d\udc1b Issue Tracker</li> <li>\ud83d\udcac Discussions</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions! Here's how you can help:</p> <ol> <li>Fork the repository</li> <li>Create a feature branch</li> <li>Write your changes</li> <li>Submit a pull request</li> </ol> <p>Please ensure your code follows our coding standards and includes appropriate tests.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"#support-the-project","title":"Support the Project","text":"<ul> <li>\u2b50 Star the repository</li> <li>\ud83d\udc1b Report issues</li> <li>\ud83d\udcd6 Contribute to documentation</li> <li>\ud83e\udd1d Submit pull requests</li> </ul>"},{"location":"contribution/","title":"Contribution Guidelines","text":"<p>Thank you for considering contributing to NinjaExtra! Your contributions help make the project better for everyone.  Please take a moment to review the following guidelines before getting started.</p>"},{"location":"contribution/#setting-up-the-development-environment","title":"Setting up the Development Environment","text":"<ol> <li> <p>Fork the repository: Fork the NinjaExtra repository on GitHub and clone it locally.</p> </li> <li> <p>Virtual Environment: Create and activate a virtual environment for the project.</p> </li> </ol> <pre><code>python -m venv venv\nsource venv/bin/activate  # Linux/macOS\n</code></pre> <pre><code>python -m venv venv\n.\\venv\\Scripts\\activate  # Windows\n</code></pre> <ol> <li>Install <code>flit</code>: Ensure you have <code>flit</code> installed globally.</li> </ol> <pre><code>pip install flit\n</code></pre> <ol> <li>Install Dependencies: Install development libraries and pre-commit hooks.</li> </ol> <pre><code>make install-full\n</code></pre>"},{"location":"contribution/#code-style-and-formatting","title":"Code Style and Formatting","text":"<ul> <li>Formatting: To format your code and ensure consistency, run:</li> </ul> <pre><code>make fmt\n</code></pre> <ul> <li>Linting: NinjaExtra uses <code>mypy</code> and <code>ruff</code> for linting. Run the following command to check code linting:</li> </ul> <pre><code>make lint\n</code></pre>"},{"location":"contribution/#testing","title":"Testing","text":"<ul> <li>Unit Tests: We use <code>pytest</code> for unit testing. Run the test suite:</li> </ul> <pre><code>make test\n</code></pre> <ul> <li>Test Coverage: To check test coverage:</li> </ul> <pre><code>make test-cov\n</code></pre>"},{"location":"contribution/#submitting-a-pull-request","title":"Submitting a Pull Request","text":"<ol> <li>Branch: Create a new branch for your feature or bug fix.</li> </ol> <pre><code>git checkout -b feature-branch\n</code></pre> <ol> <li> <p>Commit Messages: Follow the Conventional Commits specification for your commit messages.</p> </li> <li> <p>Push Changes: Push your branch to your forked repository.</p> </li> </ol> <pre><code>git push origin feature-branch\n</code></pre> <ol> <li>Pull Request: Open a pull request against the <code>master</code> branch of the NinjaExtra repository. Provide a clear and descriptive title and description for your changes.</li> </ol> <p>Thank you for contributing to NinjaExtra! \ud83d\ude80</p>"},{"location":"route_context/","title":"Route Context","text":"<p>The <code>RouteContext</code> object is a powerful feature in Django Ninja Extra that provides access to important request-related information throughout the request lifecycle. It acts as a central store for request data and is available within controller methods.</p> <pre><code>from typing import Any, List, Union\nfrom django.http import HttpRequest, HttpResponse\nfrom ninja.types import DictStrAny\nfrom pydantic import BaseModel, Field\n\nclass RouteContext(BaseModel):\n    permission_classes: List[Any] = Field([])  # Permission classes for the route\n    request: Union[HttpRequest, None] = None   # Django HttpRequest object\n    response: Union[HttpResponse, None] = None # Response object being built\n    args: List[Any] = Field([])               # Positional arguments\n    kwargs: DictStrAny = Field({})            # Keyword arguments\n</code></pre>"},{"location":"route_context/#accessing-routecontext","title":"Accessing RouteContext","text":"<p>Within a controller class, you can access the <code>RouteContext</code> through <code>self.context</code>. Here's a complete example:</p> <pre><code>from ninja_extra import ControllerBase, api_controller, route\nfrom ninja_extra.permissions import IsAuthenticated\nfrom ninja_jwt.authentication import JWTAuth\n\n@api_controller(\"/api\", auth=JWTAuth(), permissions=[IsAuthenticated])\nclass UserController(ControllerBase):\n\n    @route.get(\"/me\")\n    def get_user_info(self):\n        # Access the authenticated user from request\n        user = self.context.request.user\n        return {\n            \"email\": user.email,\n            \"username\": user.username\n        }\n\n    @route.post(\"/update-profile\")\n    def update_profile(self):\n        # Access and modify the response headers\n        self.context.response.headers[\"X-Profile-Updated\"] = \"true\"\n        return {\"status\": \"profile updated\"}\n\n    @route.get(\"/context-demo\")\n    def demo_context(self):\n        # Access various context properties\n        return {\n            \"request_method\": self.context.request.method,\n            \"route_kwargs\": self.context.kwargs,\n            \"permissions\": [p.__class__.__name__ for p in self.context.permission_classes]\n        }\n</code></pre>"},{"location":"route_context/#working-with-response-headers","title":"Working with Response Headers","text":"<p>The <code>RouteContext</code> provides access to the response object, allowing you to modify headers, cookies, and other response properties:</p> <pre><code>@api_controller(\"/api\")\nclass HeaderController(ControllerBase):\n\n    @route.get(\"/custom-headers\")\n    def add_custom_headers(self):\n        # Add custom headers to the response\n        response = self.context.response\n        response.headers[\"X-Custom-Header\"] = \"custom value\"\n        response.headers[\"X-API-Version\"] = \"1.0\"\n\n        return {\"message\": \"Response includes custom headers\"}\n</code></pre>"},{"location":"route_context/#using-routecontext-in-schema-validation","title":"Using RouteContext in Schema Validation","text":"<p>You can access the <code>RouteContext</code> during schema validation using the <code>service_resolver</code>. This is useful when you need request information during validation:</p> <pre><code>from ninja_extra import service_resolver\nfrom ninja_extra.context import RouteContext\nfrom ninja import ModelSchema\nfrom pydantic import field_validator\nfrom django.urls import reverse\n\nclass UserProfileSchema(ModelSchema):\n    avatar_url: str\n\n    class Config:\n        model = UserProfile\n        model_fields = [\"avatar_url\", \"bio\"]\n\n    @field_validator(\"avatar_url\", mode=\"before\")\n    def make_absolute_url(cls, value):\n        # Get RouteContext to access request\n        context: RouteContext = service_resolver(RouteContext)\n\n        # Convert relative URL to absolute using request\n        if value and not value.startswith(('http://', 'https://')):\n            return context.request.build_absolute_uri(value)\n        return value\n</code></pre>"},{"location":"route_context/#permissions-and-authentication","title":"Permissions and Authentication","text":"<p>The <code>RouteContext</code> stores permission classes that apply to the current route. This is particularly useful when implementing custom permission logic:</p> <pre><code>from ninja_extra import api_controller, route\nfrom ninja_extra.permissions import BasePermission\n\nclass HasAPIKey(BasePermission):\n    def has_permission(self, request, controller):\n        return request.headers.get('X-API-Key') == 'valid-key'\n\n@api_controller(\"/api\", permissions=[HasAPIKey])\nclass SecureController(ControllerBase):\n\n    @route.get(\"/secure\")\n    def secure_endpoint(self):\n        # Access current permissions\n        applied_permissions = self.context.permission_classes\n\n        return {\n            \"message\": \"Access granted\",\n            \"permissions\": [p.__class__.__name__ for p in applied_permissions]\n        }\n</code></pre>"},{"location":"route_context/#common-patterns","title":"Common Patterns","text":""},{"location":"route_context/#accessing-request-user","title":"Accessing Request User","text":"<p>Using the <code>request</code> property, you can access the authenticated user from the request object. <pre><code>@route.get(\"/profile\")\ndef get_profile(self):\n    user = self.context.request.user\n    return {\"username\": user.username}\n</code></pre></p>"},{"location":"route_context/#adding-response-headers","title":"Adding Response Headers","text":"<p>With the <code>response</code> property, you can add custom headers to the response.</p> <pre><code>@route.get(\"/download\")\ndef download_file(self):\n    self.context.response.headers[\"Content-Disposition\"] = \"attachment; filename=doc.pdf\"\n    return {\"file_url\": \"path/to/file\"}\n</code></pre>"},{"location":"route_context/#using-route-arguments","title":"Using Route Arguments","text":"<p>The <code>kwargs</code> property contains the keyword arguments passed to the route function.</p> <pre><code>@route.get(\"/items/{item_id}\")\ndef get_item(self, item_id: int):\n    # Access route parameters\n    print(self.context.kwargs)  # {'item_id': 123}\n    return {\"item_id\": item_id}\n</code></pre> <p>The <code>RouteContext</code> provides a clean way to access request data and modify responses within your controller methods. By understanding and properly utilizing <code>RouteContext</code>, you can write more maintainable and feature-rich APIs.</p>"},{"location":"settings/","title":"Settings","text":"<p>Django-Ninja-Extra has some settings that can be overridden by adding a <code>NINJA_EXTRA</code> field in Django <code>settings.py</code> with some key-value pair as shown below:</p> <pre><code># Django project settings.py\n\n\nNINJA_EXTRA = {\n    'PAGINATION_CLASS':\"ninja_extra.pagination.PageNumberPaginationExtra\",\n    'PAGINATION_PER_PAGE': 100,\n    'INJECTOR_MODULES': [],\n    'THROTTLE_CLASSES': [\n        \"ninja_extra.throttling.AnonRateThrottle\",\n        \"ninja_extra.throttling.UserRateThrottle\",\n    ],\n    'THROTTLE_RATES': {\n        'user': '1000/day',\n        'anon': '100/day',\n    },\n    'NUM_PROXIES': None,\n    'ORDERING_CLASS':\"ninja_extra.ordering.Ordering\",\n    'SEARCHING_CLASS':\"ninja_extra.searching.Searching\",\n    'ROUTE_CONTEXT_CLASS':\"ninja_extra.context.RouteContext\",\n}\n</code></pre> <p>You can override what you don't need. It is not necessary need to override everything.</p>"},{"location":"settings/#pagination_class","title":"<code>PAGINATION_CLASS</code>","text":"<p>It defines the default paginator class used by the <code>paginate</code> decorator function if a paginator class is not defined. default: <code>ninja_extra.pagination.LimitOffsetPagination</code></p>"},{"location":"settings/#pagination_per_page","title":"<code>PAGINATION_PER_PAGE</code>","text":"<p>It defines the default page size that is passed to the <code>PAGINATION_CLASS</code> during instantiation. default: <code>100</code></p>"},{"location":"settings/#injector_modules","title":"<code>INJECTOR_MODULES</code>","text":"<p>It contains a list of strings that defines the path to injector <code>Module</code>. default: <code>[]</code></p>"},{"location":"settings/#throttle_classes","title":"<code>THROTTLE_CLASSES</code>","text":"<p>It contains a list of strings that defines the path default throttling classes. default: <code>[     \"ninja_extra.throttling.AnonRateThrottle\",     \"ninja_extra.throttling.UserRateThrottle\", ]</code></p>"},{"location":"settings/#throttle_rates","title":"<code>THROTTLE_RATES</code>","text":"<p>It contains a key-value pair of different throttling rates which are applies to different <code>THROTTLING_CLASSES</code>. default: <code>{     'user': '1000/day',     'anon': '100/day', }</code></p>"},{"location":"settings/#ordering_class","title":"<code>ORDERING_CLASS</code>","text":"<p>It defines the default ordering class used by the <code>ordering</code> decorator function if a ordering class is not defined. default: <code>ninja_extra.ordering.Ordering</code></p>"},{"location":"settings/#searching_class","title":"<code>SEARCHING_CLASS</code>","text":"<p>It defines the default searching class used by the <code>searching</code> decorator function if a searching class is not defined. default: <code>ninja_extra.searching.Searching</code></p>"},{"location":"settings/#route_context_class","title":"<code>ROUTE_CONTEXT_CLASS</code>","text":"<p>It defines the default <code>RouteContext</code> class that will be instantiated during request processing. default: <code>ninja_extra.context.RouteContext</code></p> <p>See Route Context for more details.</p>"},{"location":"api_controller/","title":"Controller","text":"<p>Ninja-Extra APIController is responsible for handling incoming requests and returning responses to the client.</p> <p>In Ninja-Extra, there are major components to creating a controller model</p> <ul> <li>ControllerBase</li> <li>APIController Decorator</li> </ul>"},{"location":"api_controller/#controllerbase","title":"ControllerBase","text":"<p>The <code>ControllerBase</code> class is the base class for all controllers in Django Ninja Extra.  It provides the core functionality for handling requests, validating input, and returning responses in a class-based approach.</p> <p>The class includes properties and methods that are common to all controllers, such as the <code>request</code> object, <code>permission_classes</code>, and <code>response</code> object which are part of the <code>RouteContext</code>.  The request object contains information about the incoming request, such as headers, query parameters, and body data.  The permission_classes property is used to define the permissions required to access the controller's routes,  while the response object is used to construct the final response that is returned to the client.</p> <p>In addition to the core properties, the <code>ControllerBase</code> class also includes a number of utility methods that can be used to handle common tasks such as object permission checking (<code>check_object_permission</code>), creating quick responses (<code>create_response</code>), and fetching data from database (<code>get_object_or_exception</code>).  These methods can be overridden in subclasses to provide custom behavior.</p> <p>The ControllerBase class also includes a dependency injection system that allows for easy access to other services and objects within the application, such as the repository services etc.</p> <pre><code>from ninja_extra import ControllerBase, api_controller\n\n@api_controller('/users')\nclass UserControllerBase(ControllerBase):\n    ...\n</code></pre>"},{"location":"api_controller/#apicontroller-decorator","title":"APIController Decorator","text":"<p>The <code>api_controller</code> decorator is used to define a class-based controller in Django Ninja Extra.  It is applied to a ControllerBase class and takes several arguments to configure the routes and functionality of the controller.</p> <p>The first argument, <code>prefix_or_class</code>, is either a prefix string for grouping all routes registered under the controller or the class object that the decorator is applied on.</p> <p>The second argument, <code>auth</code>, is a list of all Django Ninja Auth classes that should be applied to the controller's routes.</p> <p>The third argument, <code>tags</code>, is a list of strings for OPENAPI tags purposes.</p> <p>The fourth argument, <code>permissions</code>, is a list of all permissions that should be applied to the controller's routes.</p> <p>The fifth argument, <code>auto_import</code>, defaults to true, which automatically adds your controller to auto import list.</p> <p>for example:</p> <pre><code>import typing\nfrom ninja_extra import api_controller, ControllerBase, permissions, route\nfrom django.contrib.auth.models import User\nfrom ninja.security import APIKeyQuery\nfrom ninja import ModelSchema\n\n\nclass UserSchema(ModelSchema):\n    class Config:\n        model = User\n        model_fields = ['username', 'email', 'first_name']\n\n\n@api_controller('users/', auth=[APIKeyQuery()], permissions=[permissions.IsAuthenticated])\nclass UsersController(ControllerBase):\n    @route.get('', response={200: typing.List[UserSchema]})\n    def get_users(self):\n        # Logic to handle GET request to the /users endpoint\n        users = User.objects.all()\n        return users\n\n    @route.post('create/', response={200: UserSchema})\n    def create_user(self, payload: UserSchema):\n        # Logic to handle POST request to the /users endpoint\n        new_user = User.objects.create(\n            username=payload.username,\n            email=payload.email,\n            first_name=payload.first_name,\n        )\n        new_user.set_password('password')\n        return new_user\n</code></pre> <p>In the above code, we have defined a controller called <code>UsersController</code> using the <code>api_controller</code> decorator.  The decorator is applied to the class and takes two arguments, the URL endpoint <code>/users</code> and <code>auth</code> and <code>permission</code> classes.  And <code>get_users</code> and <code>create_user</code> are route function that handles GET <code>/users</code> and POST <code>/users/create</code> incoming request.</p> <p>Info</p> <p>Inheriting from ControllerBase class gives you more IDE intellisense support.</p>"},{"location":"api_controller/#quick-example","title":"Quick Example","text":"<p>Let's create an APIController to properly manage Django user model</p> <pre><code>import uuid\nfrom ninja import ModelSchema\nfrom ninja_extra import (\n    http_get, http_post, http_generic, http_delete,\n    api_controller, status, ControllerBase, pagination\n)\nfrom ninja_extra.controllers.response import Detail\nfrom django.contrib.auth import get_user_model\n\n\nclass UserSchema(ModelSchema):\n    class Config:\n        model = get_user_model()\n        model_fields = ['username', 'email', 'first_name']\n\n\n@api_controller('/users')\nclass UsersController(ControllerBase):\n    user_model = get_user_model()\n\n    @http_post()\n    def create_user(self, user: UserSchema):\n        # just simulating created user\n        return dict(id=uuid.uuid4())\n\n    @http_generic('/{int:user_id}', methods=['put', 'patch'], response=UserSchema)\n    def update_user(self, user_id: int):\n        \"\"\" Django Ninja will serialize Django ORM model to schema provided as `response`\"\"\"\n        user = self.get_object_or_exception(self.user_model, id=user_id)\n        return user\n\n    @http_delete('/{int:user_id}', response=Detail(status_code=status.HTTP_204_NO_CONTENT))\n    def delete_user(self, user_id: int):\n        user = self.get_object_or_exception(self.user_model, id=user_id)\n        user.delete()\n        return self.create_response('', status_code=status.HTTP_204_NO_CONTENT)\n\n    @http_get(\"\", response=pagination.PaginatedResponseSchema[UserSchema])\n    @pagination.paginate(pagination.PageNumberPaginationExtra, page_size=50)\n    def list_user(self):\n        return self.user_model.objects.all()\n\n    @http_get('/{user_id}', response=UserSchema)\n    def get_user_by_id(self, user_id: int):\n        user = self.get_object_or_exception(self.user_model, id=user_id)\n        return user\n</code></pre> <p>In the example above, the <code>UsersController</code> class defines several methods that correspond to different HTTP methods,  such as <code>create_user</code>, <code>update_user</code>, <code>delete_user</code>, <code>list_user</code> and <code>get_user_by_id</code>.  These methods are decorated with <code>http_post</code>, <code>http_generic</code>, <code>http_delete</code>, <code>http_get</code> decorators respectively.</p> <p>The <code>create_user</code> method uses <code>http_post</code> decorator and accepts a user argument of type <code>UserSchema</code>,  which is a <code>ModelSchema</code> that is used to validate and serialize the input data.  The method is used to create a new user in the system and return an <code>ID</code> of the user.</p> <p>The <code>update_user</code> method uses <code>http_generic</code> decorator and accepts a <code>user_id</code> argument of type int.  The decorator is configured to handle both <code>PUT</code> and <code>PATCH</code> methods and  provides a response argument of type <code>UserSchema</code> which will be used to serialize the user object.</p> <p>The <code>delete_user</code> method uses <code>http_delete</code> decorator and accepts a <code>user_id</code> argument of type int and a response argument of type  Detail which will be used to return a 204 status code with an empty body on success.</p> <p>The <code>list_user</code> method uses <code>http_get</code> decorator and decorated with <code>pagination.paginate</code> decorator that paginate the results of the method using <code>PageNumberPaginationExtra</code> class with page_size=50.  It also provides a response argument of type <code>pagination.PaginatedResponseSchema[UserSchema]</code> which will be used to serialize and paginate the list of users returned by the method.</p> <p>The <code>get_user_by_id</code> method uses <code>http_get</code> decorator and accepts a <code>user_id</code> argument of type int and a response argument of type UserSchema which will be used to serialize the user object.</p> <p>The UsersController also use <code>self.get_object_or_exception(self.user_model, id=user_id)</code> which is a helper method that will raise an exception if the user object is not found.</p>"},{"location":"api_controller/api_controller_async_permission/","title":"Async Permissions in Django Ninja Extra","text":"<p>This guide explains how to use the asynchronous permissions system in Django Ninja Extra for efficient permission handling with async views and models.</p>"},{"location":"api_controller/api_controller_async_permission/#introduction","title":"Introduction","text":"<p>Django Ninja Extra provides an asynchronous permissions system that builds upon the existing permissions framework, adding support for async/await syntax. This is particularly useful when:</p> <ul> <li>Working with async views and controllers</li> <li>Performing permission checks that involve database queries</li> <li>Building efficient APIs that don't block the event loop</li> </ul> <p>The permission system in Django Ninja Extra has been redesigned to seamlessly integrate both synchronous and asynchronous permissions, making it easy to:</p> <ul> <li>Create async-first permission classes</li> <li>Mix sync and async permissions with logical operators</li> <li>Use dependency injection with permissions</li> <li>Easily migrate from sync to async permissions</li> </ul>"},{"location":"api_controller/api_controller_async_permission/#creating-async-permissions","title":"Creating Async Permissions","text":""},{"location":"api_controller/api_controller_async_permission/#basic-async-permission","title":"Basic Async Permission","text":"<p>To create a custom async permission, inherit from <code>AsyncBasePermission</code> and implement the <code>has_permission_async</code> method:</p> <pre><code>from ninja_extra.permissions import AsyncBasePermission\n\nclass IsUserPremiumAsync(AsyncBasePermission):\n    async def has_permission_async(self, request, controller):\n        # You can perform async database operations here\n        user = request.user\n\n        # Async check (example using Django's async ORM methods)\n        subscription = await user.subscription.aget()\n        return subscription and subscription.is_premium\n\n    # The sync version is automatically handled for you\n    # through async_to_sync conversion\n</code></pre>"},{"location":"api_controller/api_controller_async_permission/#using-built-in-permissions","title":"Using Built-in Permissions","text":"<p>Django Ninja Extra's permission system automatically handles both sync and async operations for built-in permissions:</p> <pre><code>from ninja_extra import api_controller, http_get\nfrom ninja_extra.permissions import IsAuthenticated, IsAdminUser\n\n@api_controller(permissions=[IsAuthenticated])\nclass UserController:\n    @http_get(\"/profile\", permissions=[IsAdminUser])\n    async def get_admin_profile(self, request):\n        # Only accessible to admin users\n        # IsAdminUser works with async views automatically\n        return {\"message\": \"Admin profile\"}\n</code></pre>"},{"location":"api_controller/api_controller_async_permission/#combining-permissions-with-logical-operators","title":"Combining Permissions with Logical Operators","text":"<p>The permission system supports combining permissions using logical operators (<code>&amp;</code>, <code>|</code>, <code>~</code>):</p> <pre><code>from ninja_extra import api_controller, http_get\nfrom ninja_extra.permissions import IsAuthenticated, IsAdminUser, AsyncBasePermission\n\n# Custom async permission\nclass HasPremiumSubscriptionAsync(AsyncBasePermission):\n    async def has_permission_async(self, request, controller):\n        # Async check\n        user_profile = await request.user.profile.aget()\n        return user_profile.has_premium_subscription\n\n@api_controller(\"/content\")\nclass ContentController:\n    # User must be authenticated AND have premium subscription\n    @http_get(\"/premium\", permissions=[IsAuthenticated() &amp; HasPremiumSubscriptionAsync()])\n    async def premium_content(self, request):\n        return {\"content\": \"Premium content\"}\n\n    # User must be authenticated OR an admin\n    @http_get(\"/special\", permissions=[IsAuthenticated() | IsAdminUser()])\n    async def special_content(self, request):\n        return {\"content\": \"Special content\"}\n\n    # User must be authenticated but NOT an admin\n    @http_get(\"/regular\", permissions=[IsAuthenticated() &amp; ~IsAdminUser()])\n    async def regular_content(self, request):\n        return {\"content\": \"Regular user content\"}\n</code></pre>"},{"location":"api_controller/api_controller_async_permission/#how-permission-operators-work","title":"How Permission Operators Work","text":"<p>When permissions are combined with logical operators, they create instances of <code>AND</code>, <code>OR</code>, or <code>NOT</code> classes that automatically handle both sync and async permissions:</p> <ul> <li>AND: Both permissions must return <code>True</code> (short-circuits on first <code>False</code>)</li> <li>OR: At least one permission must return <code>True</code> (short-circuits on first <code>True</code>)</li> <li>NOT: Inverts the result of the permission</li> </ul> <p>The operators intelligently dispatch to either <code>has_permission</code>/<code>has_object_permission</code> or <code>has_permission_async</code>/<code>has_object_permission_async</code> depending on the context and permission types.</p>"},{"location":"api_controller/api_controller_async_permission/#mixing-sync-and-async-permissions","title":"Mixing Sync and Async Permissions","text":"<p>You can seamlessly mix regular permissions with async permissions:</p> <pre><code>from ninja_extra import api_controller, http_get\nfrom ninja_extra.permissions import IsAuthenticated, IsAdminUser, AsyncBasePermission\n\n# Custom async permission\nclass IsProjectMemberAsync(AsyncBasePermission):\n    async def has_permission_async(self, request, controller):\n        project_id = controller.kwargs.get('project_id')\n        if not project_id:\n            return False\n\n        # Async database query\n        return await is_member_of_project(request.user.id, project_id)\n\n@api_controller(\"/projects\")\nclass ProjectController:\n    # Mixing sync and async permissions\n    @http_get(\"/{project_id}/details\", permissions=[IsAuthenticated() &amp; IsProjectMemberAsync()])\n    async def project_details(self, request, project_id: int):\n        # The framework automatically handles the conversion between sync and async\n        project = await get_project_by_id(project_id)\n        return project\n</code></pre> <p>The permission system automatically handles conversions between sync and async:</p> <ul> <li>When an async view calls a sync permission, it's wrapped with <code>sync_to_async</code></li> <li>When a sync view calls an async permission, it's wrapped with <code>async_to_sync</code></li> <li>Logical operators (<code>AND</code>, <code>OR</code>, <code>NOT</code>) intelligently handle mixed permission types</li> </ul>"},{"location":"api_controller/api_controller_async_permission/#object-level-permissions","title":"Object-Level Permissions","text":"<p>For object-level permissions, implement the <code>has_object_permission_async</code> method:</p> <pre><code>class IsOwnerAsync(AsyncBasePermission):\n    async def has_object_permission_async(self, request, controller, obj):\n        # Async check on the object\n        return obj.owner_id == request.user.id\n\n@api_controller(\"/posts\")\nclass PostController:\n    @http_get(\"/{post_id}\")\n    async def get_post(self, request, post_id: int):\n        # The async_check_object_permissions method will be called automatically\n        # when using aget_object_or_exception or aget_object_or_none\n        post = await self.aget_object_or_exception(Post, id=post_id)\n        return {\"title\": post.title, \"content\": post.content}\n</code></pre>"},{"location":"api_controller/api_controller_async_permission/#using-dependency-injection-with-permissions","title":"Using Dependency Injection with Permissions","text":"<p>Django Ninja Extra's permission system now integrates with dependency injection:</p> <pre><code>from injector import inject\nfrom ninja_extra import api_controller, http_get, service_resolver\nfrom ninja_extra.permissions import AsyncBasePermission\n\nclass FeatureService:\n    def has_feature_access(self, user, feature):\n        # Check if user has access to a specific feature\n        return getattr(user, f'has_{feature}', False)\n\n\nclass FeaturePermission(AsyncBasePermission):\n    __features__ = {}\n\n    feature: str = \"basic\"\n\n    @inject\n    def __init__(self, feature_service: FeatureService):\n        self.feature_service = feature_service\n        self.message = f\"Must have access to {self.feature} feature\"\n\n    # Async version of permission check\n    async def has_permission_async(self, request, controller):\n        return self.feature_service.has_feature_access(request.user, self.feature)\n\n    @classmethod\n    def create_as(cls, feature: str) -&gt; Type[FeaturePermission]:\n        # Create a new permission class with the same attributes\n        if feature in cls.__features__:\n            return cls.__features__[feature]\n        permission_type =  type(f\"{cls.__name__}_{feature}\", (cls,), {\"feature\": feature})\n        cls.__features__[feature] = permission_type\n        return permission_type\n\n\n@api_controller('features')\nclass FeatureController(ControllerBase):\n    @http_get('basic/', permissions=[FeaturePermission.create_as(\"basic\")])\n    async def basic_feature(self):\n        return {\"feature\": \"basic\"}\n\n    @http_get('premium/', permissions=[FeaturePermission.create_as(\"premium\")])\n    async def premium_feature(self):\n        return {\"feature\": \"premium\"}\n\n    # You can even combine injected permissions with operators\n    @http_get('both/', permissions=[FeaturePermission.create_as(\"basic\") &amp; FeaturePermission.create_as(\"premium\")])\n    async def both_features(self):\n        return {\"feature\": \"both\"}\n</code></pre> <p>The permission system automatically resolves the dependencies for injected permissions.</p>"},{"location":"api_controller/api_controller_async_permission/#how-the-permission-resolution-works","title":"How the Permission Resolution Works","text":"<p>The permission system uses a sophisticated resolution mechanism:</p> <ol> <li>Class vs Instance: Permissions can be specified as either classes (<code>IsAuthenticated</code>) or instances (<code>IsAuthenticated()</code>).</li> <li>Dependency Injection: Classes decorated with <code>@inject</code> are resolved using the dependency injector.</li> <li>Operator Handling: When permissions are combined with operators, the resolution happens lazily, only when the permission is actually checked.</li> </ol> <p>This resolution process is handled by the <code>_get_permission_object</code> method in the operation classes (<code>AND</code>, <code>OR</code>, <code>NOT</code>).</p>"},{"location":"api_controller/api_controller_async_permission/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Use <code>AsyncBasePermission</code> for async-first permission classes</li> <li>For optimal performance with database queries, use async methods like <code>aget()</code>, <code>afilter()</code>, etc.</li> <li>The permission system automatically handles conversion between sync and async contexts using <code>asgiref.sync</code></li> <li>Logical operators implement short-circuiting for efficiency</li> </ul>"},{"location":"api_controller/api_controller_async_permission/#complete-example","title":"Complete Example","text":"<pre><code>from django.contrib.auth.models import User\nfrom asgiref.sync import sync_to_async\nfrom ninja_extra import api_controller, http_get, http_post, ControllerBase\nfrom ninja_extra.permissions import AsyncBasePermission, IsAuthenticated, AllowAny\n\n# Custom async permission\nclass IsStaffOrOwnerAsync(AsyncBasePermission):\n    async def has_permission_async(self, request, controller):\n        return request.user.is_authenticated\n\n    async def has_object_permission_async(self, request, controller, obj):\n        # Either the user is staff or owns the object\n        return request.user.is_staff or obj.owner_id == request.user.id\n\n# Controller using mixed permissions\n@api_controller(\"/users\", permissions=[IsAuthenticated])\nclass UserController(ControllerBase):\n    @http_get(\"/\", permissions=[AllowAny])\n    async def list_users(self, request):\n        # Public endpoint\n        users = await sync_to_async(list)(User.objects.values('id', 'username')[:10])\n        return users\n\n    @http_get(\"/{user_id}\")\n    async def get_user(self, request, user_id: int):\n        # Protected by IsAuthenticated from the controller\n        user = await self.aget_object_or_exception(User, id=user_id)\n        return {\"id\": user.id, \"username\": user.username}\n\n    @http_post(\"/update/{user_id}\", permissions=[IsStaffOrOwnerAsync()])\n    async def update_user(self, request, user_id: int, data: dict):\n        # Protected by custom async permission\n        user = await self.aget_object_or_exception(User, id=user_id)\n        # Update user data\n        return {\"status\": \"success\"}\n</code></pre>"},{"location":"api_controller/api_controller_async_permission/#migrating-from-sync-permissions","title":"Migrating from Sync Permissions","text":"<p>If you already have sync permission classes that you want to make async, follow these steps:</p> <ol> <li>Change the base class from <code>BasePermission</code> to <code>AsyncBasePermission</code></li> <li>Implement the async methods (<code>has_permission_async</code> and <code>has_object_permission_async</code>)</li> <li>Convert any blocking operations to their async equivalents</li> <li>Update your controller to use these permissions</li> </ol> <p>The framework will automatically handle the interoperability between sync and async permissions.</p>"},{"location":"api_controller/api_controller_async_permission/#testing-async-permissions","title":"Testing Async Permissions","text":"<p>Testing async permissions is straightforward using pytest-asyncio:</p> <pre><code>import pytest\nfrom unittest.mock import Mock\nfrom django.contrib.auth.models import AnonymousUser\nfrom ninja_extra.permissions import AsyncBasePermission, IsAdminUser\n\n# Custom async permission for testing\nclass CustomAsyncPermission(AsyncBasePermission):\n    async def has_permission_async(self, request, controller):\n        return request.user.is_authenticated\n\n@pytest.mark.asyncio\nasync def test_async_permission():\n    # Create a mock request\n    authenticated_request = Mock(user=Mock(is_authenticated=True))\n    anonymous_request = Mock(user=AnonymousUser())\n\n    # Test the permission\n    permission = CustomAsyncPermission()\n    assert await permission.has_permission_async(authenticated_request, None) is True\n    assert await permission.has_permission_async(anonymous_request, None) is False\n\n    # Test with operators\n    combined = CustomAsyncPermission() &amp; IsAdminUser()\n\n    admin_request = Mock(user=Mock(is_authenticated=True, is_staff=True))\n    assert await combined.has_permission_async(admin_request, None) is True\n    assert await combined.has_permission_async(authenticated_request, None) is False\n\n    assert combined.has_permission(admin_request, None) is True\n    assert combined.has_permission(authenticated_request, None) is False\n</code></pre> <p>For controller integration tests:</p> <pre><code>@pytest.mark.asyncio\nasync def test_controller_with_permissions():\n    @api_controller(\"/test\")\n    class TestController(ControllerBase):\n        @http_get(\"/protected\", permissions=[CustomAsyncPermission()])\n        async def protected_route(self):\n            return {\"success\": True}\n\n    # Create async test client\n    client = TestAsyncClient(TestController)\n\n    # Test with anonymous user\n    response = await client.get(\"/protected\", user=AnonymousUser())\n    assert response.status_code == 403\n\n    # Test with authenticated user\n    auth_user = Mock(is_authenticated=True)\n    response = await client.get(\"/protected\", user=auth_user)\n    assert response.status_code == 200\n    assert response.json() == {\"success\": True}\n</code></pre>"},{"location":"api_controller/api_controller_permission/","title":"Django Ninja Extra Permissions Guide","text":"<p>Permissions in Django Ninja Extra provide a flexible way to control access to your API endpoints. The permission system is inspired by Django REST Framework and allows you to define both global and endpoint-specific access controls.</p>"},{"location":"api_controller/api_controller_permission/#how-permissions-work","title":"How Permissions Work","text":"<p>Permissions are checked at the start of each route function execution. They use the authentication information available in <code>request.user</code> and <code>request.auth</code> to determine if the request should be allowed to proceed.</p>"},{"location":"api_controller/api_controller_permission/#built-in-permission-classes","title":"Built-in Permission Classes","text":"<p>Django Ninja Extra comes with several built-in permission classes:</p>"},{"location":"api_controller/api_controller_permission/#1-allowany","title":"1. AllowAny","text":"<p>Allows unrestricted access to any endpoint.</p> <pre><code>from ninja_extra import permissions, api_controller, http_get\n\n@api_controller(permissions=[permissions.AllowAny])\nclass PublicController:\n    @http_get(\"/public\")\n    def public_endpoint(self):\n        return {\"message\": \"This endpoint is public\"}\n</code></pre>"},{"location":"api_controller/api_controller_permission/#2-isauthenticated","title":"2. IsAuthenticated","text":"<p>Only allows access to authenticated users.</p> <pre><code>from ninja_extra import permissions, api_controller, http_get\n\n@api_controller(permissions=[permissions.IsAuthenticated])\nclass PrivateController:\n    @http_get(\"/profile\")\n    def get_profile(self, request):\n        return {\n            \"username\": request.user.username,\n            \"email\": request.user.email\n        }\n</code></pre>"},{"location":"api_controller/api_controller_permission/#3-isauthenticatedorreadonly","title":"3. IsAuthenticatedOrReadOnly","text":"<p>Allows read-only access to unauthenticated users, but requires authentication for write operations.</p> <pre><code>from ninja_extra import permissions, api_controller, http_get, http_post\n\n@api_controller(\"/posts\", permissions=[permissions.IsAuthenticatedOrReadOnly])\nclass BlogController:\n    @http_get(\"/\")  # Accessible to everyone\n    def list_posts(self):\n        return {\"posts\": [\"Post 1\", \"Post 2\"]}\n\n    @http_post(\"/\")  # Only accessible to authenticated users\n    def create_post(self, request, title: str):\n        return {\"message\": f\"Post '{title}' created by {request.user.username}\"}\n</code></pre>"},{"location":"api_controller/api_controller_permission/#4-isadminuser","title":"4. IsAdminUser","text":"<p>Only allows access to admin users (users with <code>is_staff=True</code>).</p> <pre><code>from ninja_extra import permissions, api_controller, http_get\n\n@api_controller(\"/admin\", permissions=[permissions.IsAdminUser])\nclass AdminController:\n    @http_get(\"/stats\")\n    def get_stats(self):\n        return {\"active_users\": 100, \"total_posts\": 500}\n</code></pre>"},{"location":"api_controller/api_controller_permission/#custom-permissions","title":"Custom Permissions","text":"<p>You can create custom permissions by subclassing <code>BasePermission</code>:</p> <pre><code>from ninja_extra import permissions, api_controller, http_get\nfrom django.http import HttpRequest\n\nclass HasAPIKey(permissions.BasePermission):\n    def has_permission(self, request: HttpRequest, controller):\n        api_key = request.headers.get('X-API-Key')\n        return api_key == 'your-secret-key'\n\n@api_controller(permissions=[HasAPIKey])\nclass APIKeyProtectedController:\n    @http_get(\"/protected\")\n    def protected_endpoint(self):\n        return {\"message\": \"Access granted with valid API key\"}\n</code></pre>"},{"location":"api_controller/api_controller_permission/#object-level-permissions","title":"Object-Level Permissions","text":"<p>For fine-grained control over individual objects:</p> <pre><code>from ninja_extra import permissions, api_controller, http_get\nfrom django.http import HttpRequest\nfrom django.shortcuts import get_object_or_404\nfrom .models import Post\n\nclass IsPostAuthor(permissions.BasePermission):\n    def has_object_permission(self, request: HttpRequest, controller, obj: Post):\n        return obj.author == request.user\n\n@api_controller(\"/posts\")\nclass PostController:\n    @http_get(\"/{post_id}\", permissions=[permissions.IsAuthenticated &amp; IsPostAuthor()])\n    def get_post(self, request, post_id: int):\n        # The has_object_permission method will be called automatically\n        # when using get_object_or_exception or get_object_or_none\n        post = self.get_object_or_exception(Post, id=post_id)\n        return {\"title\": post.title, \"content\": post.content}\n</code></pre>"},{"location":"api_controller/api_controller_permission/#combining-permissions","title":"Combining Permissions","text":"<p>Django Ninja Extra supports combining permissions using logical operators:</p> <ul> <li><code>&amp;</code> (AND): Both permissions must pass</li> <li><code>|</code> (OR): At least one permission must pass</li> <li><code>~</code> (NOT): Inverts the permission</li> </ul> <pre><code>from ninja_extra import permissions, api_controller, http_get\n\nclass HasPremiumSubscription(permissions.BasePermission):\n    def has_permission(self, request, controller):\n        return request.user.has_perm('premium_subscription')\n\n@api_controller(\"/content\")\nclass ContentController:\n    @http_get(\"/basic\", permissions=[permissions.IsAuthenticated | HasPremiumSubscription()])\n    def basic_content(self):\n        return {\"content\": \"Basic content\"}\n\n    @http_get(\"/premium\", permissions=[permissions.IsAuthenticated &amp; HasPremiumSubscription()])\n    def premium_content(self):\n        return {\"content\": \"Premium content\"}\n\n    @http_get(\"/non-premium\", permissions=[permissions.IsAuthenticated &amp; ~HasPremiumSubscription()])\n    def non_premium_content(self):\n        return {\"content\": \"Content for non-premium users\"}\n</code></pre>"},{"location":"api_controller/api_controller_permission/#role-based-permissions","title":"Role-Based Permissions","text":"<p>You can dynamically check different roles or permissions for a user using a single permission class. Here's an example:</p> <p><pre><code>from ninja_extra import permissions, api_controller, http_get, http_post, http_delete\n\nclass HasRole(permissions.BasePermission):\n    def __init__(self, required_role: str):\n        self.required_role = required_role\n\n    def has_permission(self, request, controller):\n        return request.user.has_perm(self.required_role)\n\n\n@api_controller(\"/articles\", permissions=[permissions.IsAuthenticated])\nclass ArticleController:\n    @http_get(\"/\", permissions=[HasRole(\"articles.view\")])\n    def list_articles(self):\n        return {\"articles\": [\"Article 1\", \"Article 2\"]}\n\n    @http_post(\"/\", permissions=[HasRole(\"articles.add\")])\n    def create_article(self, title: str):\n        return {\"message\": f\"Article '{title}' created\"}\n\n    @http_delete(\"/{id}\", permissions=[HasRole(\"articles.delete\")])\n    def delete_article(self, id: int):\n        return {\"message\": f\"Article {id} deleted\"}\n</code></pre> In the above example, the <code>HasRole</code> permission class is used to check if the user has the <code>articles.view</code>, <code>articles.add</code> or <code>articles.delete</code> permission in different routes.</p>"},{"location":"api_controller/api_controller_permission/#interacting-with-route-function-parameters-and-routecontext","title":"Interacting with Route Function Parameters and RouteContext","text":"<p>Sometimes you need to access route function parameters within your permission class before the actual route function is executed. Django Ninja Extra provides the <code>RouteContext</code> class to handle this scenario.</p> <p>By default, permission checks are performed before route function parameters are resolved. However, you can explicitly trigger parameter resolution using the <code>RouteContext</code> class.</p>"},{"location":"api_controller/api_controller_permission/#basic-route-context-usage","title":"Basic Route Context Usage","text":"<pre><code>from ninja_extra import permissions, api_controller, http_get, ControllerBase\nfrom django.http import HttpRequest\n\nclass IsOwner(permissions.BasePermission):\n    def has_permission(self, request: HttpRequest, controller: ControllerBase):\n        # Access route context and compute parameters\n        controller.context.compute_route_parameters()\n\n        # Now you can access path and query parameters\n        user_id = controller.context.kwargs.get('user_id')\n        return request.user.id == user_id\n\n@api_controller(\"/users\")\nclass UserController:\n    @http_get(\"/{user_id}/profile\", permissions=[IsOwner()])\n    def get_user_profile(self, user_id: int):\n        return {\"message\": f\"Access granted to profile {user_id}\"}\n</code></pre>"},{"location":"api_controller/api_controller_permission/#advanced-route-context-examples","title":"Advanced Route Context Examples","text":"<p>Here are more complex examples showing different ways to use route context:</p> <pre><code>from ninja_extra import permissions, api_controller, http_get, http_post, ControllerBase\nfrom django.http import HttpRequest\nfrom typing import Optional\n\nclass HasTeamAccess(permissions.BasePermission):\n    def has_permission(self, request: HttpRequest, controller: ControllerBase):\n        # Compute parameters to access both path and query parameters\n        controller.context.compute_route_parameters()\n\n        team_id = controller.context.kwargs.get('team_id')\n        role = controller.context.kwargs.get('role', 'member')  # Default to 'member'\n\n        return request.user.has_team_permission(team_id, role)\n\nclass HasProjectAccess(permissions.BasePermission):\n    def __init__(self, required_role: str):\n        self.required_role = required_role\n\n    def has_permission(self, request: HttpRequest, controller: ControllerBase):\n        controller.context.compute_route_parameters()\n\n        # Access multiple parameters\n        project_id = controller.context.kwargs.get('project_id')\n        team_id = controller.context.kwargs.get('team_id')\n\n        return (\n            request.user.is_authenticated and\n            request.user.has_project_permission(project_id, team_id, self.required_role)\n        )\n\n@api_controller(\"/teams\")\nclass TeamProjectController:\n    @http_get(\"/{team_id}/projects/{project_id}\", permissions=[HasTeamAccess() &amp; HasProjectAccess(\"viewer\")])\n    def get_project(self, team_id: int, project_id: int):\n        return {\"message\": f\"Access granted to project {project_id} in team {team_id}\"}\n\n    @http_post(\"/{team_id}/projects\", permissions=[HasTeamAccess() &amp; HasProjectAccess(\"admin\")])\n    def create_project(self, team_id: int, name: str, description: Optional[str] = None):\n        return {\n            \"message\": f\"Created project '{name}' in team {team_id}\",\n            \"description\": description\n        }\n</code></pre>"},{"location":"api_controller/api_controller_permission/#working-with-query-parameters","title":"Working with Query Parameters","text":"<p>You can also access query parameters in your permission classes:</p> <pre><code>from ninja_extra import permissions, api_controller, http_get, ControllerBase\nfrom django.http import HttpRequest\n\nclass HasFeatureAccess(permissions.BasePermission):\n    def has_permission(self, request: HttpRequest, controller: ControllerBase):\n        controller.context.compute_route_parameters()\n\n        # Access query parameters\n        feature_name = controller.context.kwargs.get('feature')\n        environment = controller.context.kwargs.get('env', 'production')\n\n        return request.user.has_feature_access(feature_name, environment)\n\n@api_controller(\"/features\")\nclass FeatureController:\n    @http_get(\"/check\", permissions=[HasFeatureAccess()])\n    def check_feature(self, feature: str, env: str = \"production\"):\n        return {\n            \"feature\": feature,\n            \"environment\": env,\n            \"status\": \"enabled\"\n        }\n</code></pre>"},{"location":"api_controller/api_controller_permission/#important-notes","title":"Important Notes","text":"<ol> <li>Always call <code>compute_route_parameters()</code> before accessing route parameters in permission classes</li> <li>Route parameters are available in <code>controller.context.kwargs</code> after computation</li> <li>Both path parameters and query parameters are accessible</li> <li>You can combine route context-based permissions with other permission types</li> <li>Route parameters are computed only once, even if accessed by multiple permission classes</li> <li>The computation results are cached for the duration of the request</li> </ol>"},{"location":"api_controller/api_controller_route/","title":"APIController Route Decorator","text":"<p>The <code>route</code> class is a function decorator designed to annotate a Controller class function as an endpoint with a specific HTTP method.</p> <p>For instance: <pre><code>from ninja_extra import route, api_controller\n\n@api_controller\nclass MyController:\n    @route.get('/test')\n    def test(self):\n        return {'message': 'test'}\n</code></pre> The <code>route</code> provides predefined methods that simplify the creation of various operations, and their names align with the respective HTTP methods:</p> <ul> <li>GET: <code>route.get</code></li> <li>POST: <code>route.post</code></li> <li>PUT: <code>route.put</code></li> <li>DELETE: <code>route.delete</code></li> <li>PATCH: <code>route.patch</code></li> <li>GENERIC - for combinations of operations, e.g., <code>route.generic(methods=['POST', 'PATCH'])</code></li> </ul>"},{"location":"api_controller/api_controller_route/#initialization-parameters","title":"Initialization Parameters","text":"<p>Here's a summarized description of the parameters for the <code>route</code> class in NinjaExtra:</p> <ul> <li> <p><code>path</code>: A required unique endpoint path string.</p> </li> <li> <p><code>methods</code>: A collection of required HTTP methods for the endpoint, e.g., <code>['POST', 'PUT']</code>.</p> </li> <li> <p><code>auth</code>: Defines the authentication method for the endpoint. Default: <code>NOT_SET</code></p> </li> <li> <p><code>response</code>: Defines the response format as <code>dict[status_code, schema]</code> or <code>Schema</code>. It is used to validate the returned response.Default: <code>NOT_SET</code></p> </li> <li> <p><code>operation_id</code>: An optional unique identifier distinguishing operations in path view.Default: <code>NOT_SET</code></p> </li> <li> <p><code>summary</code>: An optional summary describing the endpoint. Default: <code>None</code></p> </li> <li> <p><code>description</code>: An optional description providing additional details about the endpoint. Default: <code>None</code></p> </li> <li> <p><code>tags</code>: A list of strings for grouping the endpoint for documentation purposes. Default: <code>None</code></p> </li> <li> <p><code>deprecated</code>: An optional boolean parameter indicating if the endpoint is deprecated. Default: <code>None</code></p> </li> <li> <p><code>by_alias</code>: An optional parameter applied to filter the <code>response</code> schema object. Default: <code>False</code></p> </li> <li> <p><code>exclude_unset</code>: An optional parameter applied to filter the <code>response</code> schema object.  Default: <code>False</code></p> </li> <li> <p><code>exclude_defaults</code>: An optional parameter applied to filter the <code>response</code> schema object.  Default: <code>False</code></p> </li> <li> <p><code>exclude_none</code>: An optional parameter applied to filter the <code>response</code> schema object.  Default: <code>False</code></p> </li> <li> <p><code>include_in_schema</code>: Indicates whether the endpoint should appear on the Swagger documentation.  Default: <code>True</code></p> </li> <li> <p><code>url_name</code>: Gives a name to the endpoint that can be resolved using the <code>reverse</code> function in Django.  Default: <code>None</code></p> </li> <li> <p><code>permissions</code>: Defines a collection of route permission classes for the endpoint. Default: <code>None</code></p> </li> </ul> <p>These parameters serve a similar purpose to those used in creating an endpoint in Django-Ninja  but have been abstracted to apply to Controller classes in NinjaExtra.</p>"},{"location":"api_controller/api_controller_route/#async-route-definition","title":"Async Route Definition","text":"<p>In Django-Ninja-Extra, the <code>route</code> class supports the definition of asynchronous endpoints, similar to Django-Ninja.  This feature is available for Django versions greater than 3.0.</p> <p>For example:</p> <pre><code>import asyncio\nfrom ninja_extra import http_get, api_controller\n\n@api_controller\nclass MyController:\n    @http_get(\"/say-after\")\n    async def say_after(self, delay: int, word: str):\n        await asyncio.sleep(delay)\n        return {'saying': word}\n</code></pre> <p>In this illustration, the <code>say_after</code> endpoint is defined as an asynchronous function using the <code>async</code>  keyword, allowing for asynchronous operations within the endpoint.</p> <p>Info</p> <p>Read more on Django-Ninja Async Support</p>"},{"location":"api_controller/model_controller/","title":"Model APIController","text":"<p>Model Controllers dynamically generate CRUD (Create, Read, Update, Delete) operations for a Django ORM model within a controller, based on specified configurations.</p> <p>Model Controllers extend the <code>ControllerBase</code> class and introduce two configuration variables, namely <code>model_config</code> and <code>model_service</code>. </p> <ul> <li><code>model_config</code> is responsible for defining configurations related to routes and schema generation</li> <li><code>model_service</code> refers to a class that manages CRUD (Create, Read, Update, Delete) operations for the specified model.</li> </ul> <p>For example, consider the definition of an <code>Event</code> model in Django:</p> <pre><code>from django.db import models\n\nclass Category(models.Model):\n    title = models.CharField(max_length=100)\n\nclass Event(models.Model):\n    title = models.CharField(max_length=100)\n    category = models.OneToOneField(\n        Category, null=True, blank=True, on_delete=models.SET_NULL, related_name='events'\n    )\n    start_date = models.DateField()\n    end_date = models.DateField()\n\n    def __str__(self):\n        return self.title\n</code></pre> <p>Now, let's create a <code>ModelController</code> for the <code>Event</code> model. In the <code>api.py</code> file, we define an <code>EventModelController</code>:</p> <pre><code>from ninja_extra import (\n    ModelConfig,\n    ModelControllerBase,\n    ModelSchemaConfig,\n    api_controller,\n    NinjaExtraAPI\n)\nfrom .models import Event\n\n@api_controller(\"/events\")\nclass EventModelController(ModelControllerBase):\n    model_config = ModelConfig(\n        model=Event,\n        schema_config=ModelSchemaConfig(\n            read_only_fields=[\"id\", \"category\"],\n            # if you want to extra configuration to the generated schemas\n            # extra_config_dict={\n            #     'title': 'EventCustomTitle',\n            #      'populate_by_name': True\n            # } \n        ),\n    )\n\napi = NinjaExtraAPI()\napi.register_controllers(EventModelController)\n</code></pre> <p>It's important to note that Model Controllers rely on the <code>ninja-schema</code> package for automatic schema generation. To install the package, use the following command:</p> <pre><code>pip install ninja-schema\n</code></pre> <p>After installation, you can access the auto-generated API documentation by visiting  http://localhost:8000/api/docs. </p> <p>This documentation provides a detailed overview of the available routes, schemas, and functionalities  exposed by the <code>EventModelController</code> for the <code>Event</code> model.</p>"},{"location":"api_controller/model_controller/#model-configuration","title":"Model Configuration","text":"<p>The <code>ModelConfig</code> is a Pydantic schema designed for validating and configuring the behavior of Model Controllers. Key configuration options include:</p> <ul> <li>model: A mandatory field representing the Django model type associated with the Model Controller.</li> <li>async_routes: Indicates if controller routes should be created as <code>asynchronous</code> route functions</li> <li>allowed_routes: A list specifying the API actions permissible for generation in the Model Controller. The default value is <code>[\"create\", \"find_one\", \"update\", \"patch\", \"delete\", \"list\"]</code>.</li> <li>create_schema: An optional Pydantic schema outlining the data input types for a <code>create</code> or <code>POST</code> operation in the Model Controller. The default is <code>None</code>. If not provided, the <code>ModelController</code> will generate a new schema based on the <code>schema_config</code> option.</li> <li>update_schema: An optional Pydantic schema detailing the data input types for an <code>update</code> or <code>PUT</code> operation in the Model Controller. The default is <code>None</code>. If not provided, the <code>create_schema</code> will be used if available, or a new schema will be generated based on the <code>schema_config</code> option.</li> <li>retrieve_schema: An optional Pydantic schema output defining the data output types for various operations. The default is <code>None</code>. If not provided, the <code>ModelController</code> will generate a schema based on the <code>schema_config</code> option.</li> <li>patch_schema: An optional Pydantic schema output specifying the data input types for <code>patch/PATCH</code> operations. The default is <code>None</code>. If not provided, the <code>ModelController</code> will generate a schema with all its fields optional.</li> <li>schema_config: Another mandatory field describing the schema generation approach required by Model Controller operations. Configuration options encompass:<ul> <li><code>include</code>: A list of Fields to be included. The default is <code>__all__</code>.</li> <li><code>exclude</code>: A list of Fields to be excluded. The default is <code>[]</code>.</li> <li><code>optional</code>: A list of Fields to be enforced as optional. The default is <code>[pk]</code>.</li> <li><code>depth</code>: The depth for nesting schema generation.</li> <li><code>read_only_fields</code>: A list of fields to be excluded when generating input schemas for create, update, and patch operations.</li> <li><code>write_only_fields</code>: A list of fields to be excluded when generating output schemas for find_one and list operations.</li> <li><code>extra_config_dict</code>: A dictionary of extra configuration to be added to the generated schemas. Options must be valid Pydantic configuration options.</li> </ul> </li> <li> <p>pagination: A requisite for the model <code>list/GET</code> operation to prevent sending <code>100_000</code> items at once in a request. The pagination configuration mandates a <code>ModelPagination</code> Pydantic schema object for setup. Options encompass:</p> <ul> <li><code>klass</code>: The pagination class of type <code>PaginationBase</code>. The default is <code>PageNumberPaginationExtra</code>.</li> <li><code>paginator_kwargs</code>: A dictionary value for <code>PaginationBase</code> initialization. The default is None.</li> <li><code>pagination_schema</code>: A Pydantic generic schema that combines with <code>retrieve_schema</code> to generate a response schema for the <code>list/GET</code> operation.</li> </ul> <p>For instance, if opting for <code>ninja</code> pagination like <code>LimitOffsetPagination</code>:</p> <pre><code>from ninja.pagination import LimitOffsetPagination\nfrom ninja_extra.schemas import NinjaPaginationResponseSchema\nfrom ninja_extra import (\n    ModelConfig,\n    ModelControllerBase,\n    api_controller,\n    ModelPagination\n)\n\n@api_controller(\"/events\")\nclass EventModelController(ModelControllerBase):\n    model_config = ModelConfig(\n        model=Event,\n        pagination=ModelPagination(\n            klass=LimitOffsetPagination, \n            pagination_schema=NinjaPaginationResponseSchema\n        ),\n    )\n</code></pre> </li> </ul>"},{"location":"api_controller/model_controller/#more-on-model-controller-operations","title":"More on Model Controller Operations","text":"<p>In NinjaExtra Model Controller, the controller's behavior can be controlled by what is provided in the <code>allowed_routes</code>  list within the <code>model_config</code> option.</p> <p>For example, you can create a read-only controller like this:</p> <p><pre><code>from ninja_extra import api_controller, ModelControllerBase, ModelConfig, ModelSchemaConfig\nfrom .models import Event\n\n@api_controller(\"/events\")\nclass EventModelController(ModelControllerBase):\n    model_config = ModelConfig(\n        model=Event,\n        allowed_routes=['find_one', 'list'],\n        schema_config=ModelSchemaConfig(read_only_fields=[\"id\", \"category\"]),\n    )\n</code></pre> This will only create <code>GET/{id}</code> and <code>GET/</code> routes for listing.</p> <p>You can also add more endpoints to the existing <code>EventModelController</code>. For example:</p> <pre><code>from ninja_extra import api_controller, http_get, ModelControllerBase, ModelConfig, ModelSchemaConfig\nfrom .models import Event\n\n@api_controller(\"/events\")\nclass EventModelController(ModelControllerBase):\n    model_config = ModelConfig(\n        model=Event,\n        allowed_routes=['find_one', 'list'],\n        schema_config=ModelSchemaConfig(read_only_fields=[\"id\", \"category\"]),\n    )\n\n    @http_get('/subtract',)\n    def subtract(self, a: int, b: int):\n        \"\"\"Subtracts a from b\"\"\"\n        return {\"result\": a - b}\n</code></pre>"},{"location":"api_controller/model_controller/#model-service","title":"Model Service","text":"<p>Every model controller has a <code>ModelService</code> instance created during runtime to manage model interaction with the controller.  Usually, these model service actions would have been part of the model controller,  but they are abstracted to a service to allow a more dynamic approach.</p> <p><pre><code>class ModelService(ModelServiceBase):\n    \"\"\"\n    Model Service for Model Controller model CRUD operations with simple logic for simple models.\n\n    It's advised to override this class if you have a complex model.\n    \"\"\"\n    def __init__(self, model: Type[DjangoModel]) -&gt; None:\n        self.model = model\n\n    # ... (other CRUD methods)\n</code></pre> These actions are called based on the ongoing action on the model controller or  based on the request being handled by the model controller.</p>"},{"location":"api_controller/model_controller/#using-custom-model-service","title":"Using Custom Model Service","text":"<p>Overriding a <code>ModelService</code> in a Model Controller is more important than overriding a route operation.  The default <code>ModelService</code> used in the Model Controller is designed for simple Django models.  It's advised to override the <code>ModelService</code> if you have a complex model.</p> <p>For example, if you want to change the way the <code>Event</code> model is being saved: <pre><code>from ninja_extra import ModelService\n\nclass EventModelService(ModelService):\n    def create(self, schema: PydanticModel, **kwargs: Any) -&gt; Any:\n        data = schema.dict(by_alias=True)\n        data.update(kwargs)\n\n        instance = self.model._default_manager.create(**data)\n        return instance\n</code></pre> And then in <code>api.py</code> <pre><code>from ninja_extra import (\n    ModelConfig,\n    ModelControllerBase,\n    ModelSchemaConfig,\n    api_controller,\n)\nfrom .service import EventModelService\nfrom .models import Event\n\n@api_controller(\"/events\")\nclass EventModelController(ModelControllerBase):\n    service = EventModelService(model=Event)\n    model_config = ModelConfig(\n        model=Event,\n        schema_config=ModelSchemaConfig(read_only_fields=[\"id\", \"category\"]),\n    )\n</code></pre></p>"},{"location":"api_controller/model_controller/#enable-async-routes","title":"Enable Async Routes","text":"<p>In <code>model_config</code>, set <code>async_routes</code> to <code>True</code></p> <pre><code>from ninja_extra import (\n    ModelConfig,\n    ModelControllerBase,\n    ModelSchemaConfig,\n    api_controller,\n)\nfrom .service import EventModelService\nfrom .models import Event\n\n\n@api_controller(\"/events\")\nclass EventModelController(ModelControllerBase):\n    service = EventModelService(model=Event)\n    model_config = ModelConfig(\n        model=Event,\n        async_routes=True,\n        schema_config=ModelSchemaConfig(read_only_fields=[\"id\", \"category\"]),\n    )\n</code></pre> <p>By setting the <code>async_routes</code> parameter to <code>True</code> in the <code>model_config</code>, the <code>ModelController</code>  dynamically switches between <code>ModelAsyncEndpointFactory</code> and  <code>ModelEndpointFactory</code> to generate  either asynchronous or synchronous endpoints based on the configuration.</p>"},{"location":"api_controller/model_controller/#modelcontroller-and-modelservice-together","title":"ModelController and ModelService Together","text":"<p>It's also possible to merge the controller and the model service together if needed:</p> <p>For example, using the <code>EventModelService</code> we created <pre><code>from ninja_extra import (\n    ModelConfig,\n    ModelControllerBase,\n    ModelSchemaConfig,\n    api_controller,\n)\nfrom .service import EventModelService\nfrom .models import Event\n\n@api_controller(\"/events\")\nclass EventModelController(ModelControllerBase, EventModelService):\n    model_config = ModelConfig(\n        model=Event,\n        schema_config=ModelSchemaConfig(read_only_fields=[\"id\", \"category\"]),\n    )\n\n    def __init__(self):\n        EventModelService.__init__(self, model=Event)\n        self.service = self  # This will expose the functions to the service attribute\n</code></pre></p>"},{"location":"api_controller/model_controller/#model-endpoint-factory","title":"Model Endpoint Factory","text":"<p>The <code>ModelEndpointFactory</code> is a factory class used by the Model Controller to generate endpoints seamlessly.  It can also be used directly in any NinjaExtra Controller for the same purpose.</p> <p>For example, if we want to add an <code>Event</code> to a new <code>Category</code>, we can do so as follows: <pre><code>from typing import Any\nfrom pydantic import BaseModel\nfrom ninja_extra import (\n    ModelConfig,\n    ModelControllerBase,\n    ModelSchemaConfig,\n    api_controller,\n    ModelEndpointFactory\n)\nfrom .models import Event, Category\n\nclass CreateCategorySchema(BaseModel):\n    title: str\n\nclass CategorySchema(BaseModel):\n    id: str\n    title: str\n\n@api_controller(\"/events\")\nclass EventModelController(ModelControllerBase):\n    model_config = ModelConfig(\n        model=Event,\n        schema_config=ModelSchemaConfig(read_only_fields=[\"id\", \"category\"]),\n    )\n\n    add_event_to_new_category = ModelEndpointFactory.create(\n        path=\"/{int:event_id}/new-category\",\n        schema_in=CreateCategorySchema,\n        schema_out=CategorySchema,\n        custom_handler=lambda self, data, **kw: self.handle_add_event_to_new_category(data, **kw)\n    )\n\n    def handle_add_event_to_new_category(\n        self, data: CreateCategorySchema, event_id: int, **kw: Any\n    ) -&gt; Category:\n        event = self.service.get_one(pk=event_id)\n        category = Category.objects.create(title=data.title)\n        event.category = category\n        event.save()\n        return category\n</code></pre></p> <p>In the above example, we created an endpoint <code>POST /{int:event_id}/new-category</code> using <code>ModelEndpointFactory.create</code>  and passed in input and output schemas along with a custom handler.  By passing in a <code>custom_handler</code>, the generated route function will delegate its handling action to the provided  <code>custom_handler</code> instead of calling <code>service.create</code>.</p>"},{"location":"api_controller/model_controller/#async-model-endpoint-factory","title":"Async Model Endpoint Factory","text":"<p>The <code>ModelAsyncEndpointFactory</code> shares the same API interface as <code>ModelEndpointFactory</code>  but is specifically designed for generating asynchronous endpoints.</p> <p>we can create same example as with <code>ModelEndpointFactory</code>,</p> <p>For example:</p> <p><pre><code>from typing import Any\nfrom pydantic import BaseModel\nfrom ninja_extra import (\n    ModelConfig,\n    ModelControllerBase,\n    ModelSchemaConfig,\n    api_controller,\n    ModelAsyncEndpointFactory\n)\nfrom .models import Event, Category\n\nclass CreateCategorySchema(BaseModel):\n    title: str\n\nclass CategorySchema(BaseModel):\n    id: str\n    title: str\n\n@api_controller(\"/events\")\nclass EventModelController(ModelControllerBase):\n    model_config = ModelConfig(\n        model=Event,\n        schema_config=ModelSchemaConfig(read_only_fields=[\"id\", \"category\"]),\n    )\n\n    add_event_to_new_category = ModelAsyncEndpointFactory.create(\n        path=\"/{int:event_id}/new-category\",\n        schema_in=CreateCategorySchema,\n        schema_out=CategorySchema,\n        custom_handler=lambda self, data, **kw: self.handle_add_event_to_new_category(data, **kw)\n    )\n\n    async def handle_add_event_to_new_category(\n        self, data: CreateCategorySchema, event_id: int, **kw: Any\n    ) -&gt; Category:\n        event = await self.service.get_one_async(pk=event_id)\n        category = Category.objects.create(title=data.title)\n        event.category = category\n        event.save()\n        return category\n</code></pre> In the above illustration, we created <code>add_event_to_new_category</code> as an asynchronous function and converted  <code>handle_add_event_to_new_category</code> to asynchronous function as well. </p>"},{"location":"api_controller/model_controller/#querygetter-and-objectgetter","title":"QueryGetter and ObjectGetter","text":"<p><code>ModelEndpointFactory</code> exposes a more flexible way to get a model object or get a queryset filter in the case of  <code>ModelEndpointFactory.find_one</code> and <code>ModelEndpointFactory.list</code>, respectively.</p> <p>For example, to retrieve the category of an event (not practical but for illustration): <pre><code>from ninja_extra import (\n    ModelConfig,\n    ModelControllerBase,\n    ModelSchemaConfig,\n    api_controller,\n    ModelEndpointFactory\n)\nfrom .models import Event, Category\n\n@api_controller(\"/events\")\nclass EventModelController(ModelControllerBase):\n    model_config = ModelConfig(\n        model=Event,\n        schema_config=ModelSchemaConfig(read_only_fields=[\"id\", \"category\"]),\n    )\n\n    get_event_category = ModelEndpointFactory.find_one(\n        path=\"/{int:event_id}/category\",\n        schema_out=CategorySchema,\n        lookup_param='event_id',\n        object_getter=lambda self, pk, **kw: self.service.get_one(pk=pk).category\n    )\n</code></pre> In the above example, we created a <code>get_event_category</code> endpoint using <code>ModelEndpointFactory.find_one</code> and  provided an <code>object_getter</code> as a callback for fetching the model based on the <code>event_id</code>. And the <code>lookup_param</code> indicates the key in <code>kwargs</code> that defines the pk value used to get object model incase  there is no <code>object_getter</code> handler implemented.</p> <p>On the other hand, you can have a case where you need to list events by <code>category_id</code>: <pre><code>from ninja_extra import (\n    ModelConfig,\n    ModelControllerBase,\n    ModelSchemaConfig,\n    api_controller,\n    ModelEndpointFactory\n)\nfrom .models import Event, Category\n\n@api_controller(\"/events\")\nclass EventModelController(ModelControllerBase):\n    model_config = ModelConfig(\n        model=Event,\n        schema_config=ModelSchemaConfig(read_only_fields=[\"id\", \"category\"]),\n    )\n\n    get_events_by_category = ModelEndpointFactory.list(\n        path=\"/category/{int:category_id}/\",\n        schema_out=model_config.retrieve_schema,\n        lookup_param='category_id',\n        queryset_getter=lambda self, **kw: Category.objects.filter(pk=kw['category_id']).first().events.all()\n    )\n</code></pre> By using <code>ModelEndpointFactory.list</code> and <code>queryset_getter</code>, you can quickly set up a list endpoint that returns events belonging to a category.  Note that our <code>queryset_getter</code> may fail if an invalid ID is supplied, as this is just an illustration.</p> <p>Also, keep in mind that <code>model_config</code> settings like <code>create_schema</code>, <code>retrieve_schema</code>, <code>patch_schema</code>, and <code>update_schema</code>  are all available after ModelConfig instantiation.</p>"},{"location":"api_controller/model_controller/#path-and-query-parameters","title":"Path and Query Parameters","text":"<p>In <code>ModelEndpointFactory</code>, path parameters are parsed to identify both <code>path</code> and <code>query</code> parameters.  These parameters are then created as fields within the Ninja input schema and resolved during the request,  passing them as kwargs to the handler.</p> <p>For example, <pre><code>list_post_tags = ModelEndpointFactory.list(\n    path=\"/{int:id}/tags/{post_id}?query=int&amp;query1=int\",\n    schema_out=model_config.retrieve_schema,\n    queryset_getter=lambda self, **kw: self.list_post_tags_query(**kw)\n)\n\ndef list_post_tags_query(self, **kwargs):\n    assert kwargs['id']\n    assert kwargs['query']\n    assert kwargs['query1']\n    post_id = kwargs['post_id']\n    return Post.objects.filter(id=post_id).first().tags.all()\n</code></pre></p> <p>In this example, the path <code>/{int:id}/tags/{post_id}?query=int&amp;query1=int</code> generates two path parameters <code>['id:int', 'post_id:str']</code>  and two query parameters <code>['query:int', 'query1:int']</code>.  These parameters are bundled into the Ninja input schema and resolved during the request, passing them as kwargs to the route handler. </p> <p>Note that when <code>path</code> and <code>query</code> parameters are defined they are added to ninja schema input as a required field and, not optional.  Also, path and query data types must be compatible with Django URL converters.</p>"},{"location":"api_controller/model_controller/01_getting_started/","title":"Getting Started with Model Controllers","text":"<p>Model Controllers in Ninja Extra provide a powerful way to automatically generate CRUD (Create, Read, Update, Delete) operations for Django ORM models. They simplify API development by handling common database operations while remaining highly customizable.</p>"},{"location":"api_controller/model_controller/01_getting_started/#installation","title":"Installation","text":"<p>First, ensure you have Ninja Extra and ninja-schema installed:</p> <pre><code>pip install django-ninja-extra ninja-schema\n</code></pre> <p><code>ninja-schema</code> package is optional, but it's recommended for generating schemas.</p>"},{"location":"api_controller/model_controller/01_getting_started/#basic-usage","title":"Basic Usage","text":"<p>Let's start with a simple example. Consider this Django model:</p> <pre><code>from django.db import models\n\nclass Category(models.Model):\n    title = models.CharField(max_length=100)\n\nclass Event(models.Model):\n    title = models.CharField(max_length=100)\n    category = models.OneToOneField(\n        Category, null=True, blank=True, \n        on_delete=models.SET_NULL, \n        related_name='events'\n    )\n    start_date = models.DateField()\n    end_date = models.DateField()\n\n    def __str__(self):\n        return self.title\n</code></pre> <p>To create a basic Model Controller for the Event model:</p> <pre><code>from ninja_extra import (\n    ModelConfig,\n    ModelControllerBase,\n    api_controller,\n    NinjaExtraAPI\n)\nfrom .models import Event\n\n@api_controller(\"/events\")\nclass EventModelController(ModelControllerBase):\n    model_config = ModelConfig(\n        model=Event,\n    )\n\n# Register the controller with your API\napi = NinjaExtraAPI()\napi.register_controllers(EventModelController)\n</code></pre> <p>This simple setup automatically creates the following endpoints:</p> <ul> <li><code>POST /events/</code> - Create a new event</li> <li><code>GET /events/{id}</code> - Retrieve a specific event</li> <li><code>PUT /events/{id}</code> - Update an event</li> <li><code>PATCH /events/{id}</code> - Partially update an event</li> <li><code>DELETE /events/{id}</code> - Delete an event</li> <li><code>GET /events/</code> - List all events (with pagination)</li> </ul> <p>It is important to that if <code>model_config.model</code> is not set, the controller becomes a regular NinjaExtra controller.</p>"},{"location":"api_controller/model_controller/01_getting_started/#generated-schemas","title":"Generated Schemas","text":"<p>The Model Controller automatically generates Pydantic schemas for your model using <code>ninja-schema</code>. These schemas handle:</p> <ul> <li>Input validation</li> <li>Output serialization</li> <li>Automatic documentation in the OpenAPI schema</li> </ul> <p>For example, the generated schemas for our <code>Event</code> model would look like this:</p> <pre><code># Auto-generated create/update schema\nclass EventCreateSchema(Schema):\n    title: str\n    start_date: date\n    end_date: date\n    category: Optional[int] = None\n\n# Auto-generated retrieve schema\nclass EventSchema(Schema):\n    id: int\n    title: str\n    start_date: date\n    end_date: date\n    category: Optional[int] = None\n</code></pre>"},{"location":"api_controller/model_controller/01_getting_started/#customizing-routes","title":"Customizing Routes","text":"<p>You can control which routes are generated using the <code>allowed_routes</code> parameter:</p> <pre><code>@api_controller(\"/events\")\nclass EventModelController(ModelControllerBase):\n    model_config = ModelConfig(\n        model=Event,\n        allowed_routes=[\"list\", \"find_one\"]  # Only generate GET and GET/{id} endpoints\n    )\n</code></pre>"},{"location":"api_controller/model_controller/01_getting_started/#async-support","title":"Async Support","text":"<p>Model Controllers support <code>async</code> operations out of the box. Just set <code>async_routes=True</code>:</p> <pre><code>@api_controller(\"/events\")\nclass EventModelController(ModelControllerBase):\n    model_config = ModelConfig(\n        model=Event,\n        async_routes=True  # Enable async routes\n    )\n</code></pre>"},{"location":"api_controller/model_controller/01_getting_started/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Model Configuration for detailed schema and route customization</li> <li>Explore Model Services for customizing CRUD operations</li> <li>See how to use Query and Path Parameters effectively with <code>ModelEndpointFactory</code></li> </ul>"},{"location":"api_controller/model_controller/02_model_configuration/","title":"Model Configuration","text":"<p>The <code>ModelConfig</code> class in Ninja Extra provides extensive configuration options for Model Controllers. It allows you to customize schema generation, route behavior, and pagination settings.</p>"},{"location":"api_controller/model_controller/02_model_configuration/#basic-configuration","title":"Basic Configuration","text":"<p>Here's a comprehensive example of <code>ModelConfig</code> usage:</p> <pre><code>from ninja_extra import (\n    ModelConfig,\n    ModelControllerBase,\n    ModelSchemaConfig,\n    api_controller,\n)\nfrom .models import Event\n\n@api_controller(\"/events\")\nclass EventModelController(ModelControllerBase):\n    model_config = ModelConfig(\n        model=Event,\n        schema_config=ModelSchemaConfig(\n            read_only_fields=[\"id\", \"created_at\"],\n            write_only_fields=[\"password\"],\n            include=[\"title\", \"start_date\", \"end_date\", \"category\"],\n            exclude=set(),  # Fields to exclude\n            depth=1,  # Nesting depth for related fields\n        ),\n        async_routes=False,  # Enable/disable async routes\n        allowed_routes=[\"create\", \"find_one\", \"update\", \"patch\", \"delete\", \"list\"],\n    )\n</code></pre>"},{"location":"api_controller/model_controller/02_model_configuration/#schema-configuration","title":"Schema Configuration","text":"<p>The <code>ModelSchemaConfig</code> class controls how Pydantic schemas are generated from your Django models:</p> <pre><code>from ninja_extra import ModelConfig, ModelSchemaConfig\n\n# Detailed schema configuration\nschema_config = ModelSchemaConfig(\n    # Include specific fields (use \"__all__\" for all fields)\n    include=[\"title\", \"description\", \"start_date\"],\n\n    # Exclude specific fields\n    exclude={\"internal_notes\", \"secret_key\"},\n\n    # Fields that should be read-only (excluded from create/update schemas)\n    read_only_fields=[\"id\", \"created_at\", \"updated_at\"],\n\n    # Fields that should be write-only (excluded from retrieve schemas)\n    write_only_fields=[\"password\"],\n\n    # Depth of relationship traversal\n    depth=1,\n\n    # Additional Pydantic config options\n    extra_config_dict={\n        \"title\": \"EventSchema\",\n        \"description\": \"Schema for Event model\",\n        \"populate_by_name\": True\n    }\n)\n\nmodel_config = ModelConfig(\n    model=Event,\n    schema_config=schema_config\n)\n</code></pre>"},{"location":"api_controller/model_controller/02_model_configuration/#custom-schemas","title":"Custom Schemas","text":"<p>You can provide your own Pydantic schemas instead of using auto-generated ones:</p> <pre><code>from datetime import date\nfrom pydantic import BaseModel, Field\n\nclass EventCreateSchema(BaseModel):\n    title: str = Field(..., max_length=100)\n    start_date: date\n    end_date: date\n    category_id: int | None = None\n\nclass EventRetrieveSchema(BaseModel):\n    id: int\n    title: str\n    start_date: date\n    end_date: date\n    category_id: int | None\n\n@api_controller(\"/events\")\nclass EventModelController(ModelControllerBase):\n    model_config = ModelConfig(\n        model=Event,\n        create_schema=EventCreateSchema,\n        retrieve_schema=EventRetrieveSchema,\n        update_schema=EventCreateSchema,  # Reuse create schema for updates\n    )\n</code></pre>"},{"location":"api_controller/model_controller/02_model_configuration/#pagination-configuration","title":"Pagination Configuration","text":"<p>Model Controllers support customizable pagination for list endpoints:</p> <pre><code>from ninja.pagination import LimitOffsetPagination\nfrom ninja_extra import (\n    ModelConfig,\n    ModelPagination\n)\nfrom ninja_extra.pagination import NinjaPaginationResponseSchema\n\n@api_controller(\"/events\")\nclass EventModelController(ModelControllerBase):\n    model_config = ModelConfig(\n        model=Event,\n        # Configure pagination\n        pagination=ModelPagination(\n            klass=LimitOffsetPagination,\n            pagination_schema=NinjaPaginationResponseSchema,\n            paginator_kwargs={\n                \"limit\": 20,\n                \"offset\": 100\n            }\n        )\n    )\n</code></pre>"},{"location":"api_controller/model_controller/02_model_configuration/#route-configuration","title":"Route Configuration","text":"<p>You can customize individual route behavior using route info dictionaries:</p> <pre><code>@api_controller(\"/events\")\nclass EventModelController(ModelControllerBase):\n    model_config = ModelConfig(\n        model=Event,\n        # Customize specific route configurations\n        create_route_info={\n            \"summary\": \"Create a new event\",\n            \"description\": \"Creates a new event with the provided data\",\n            \"tags\": [\"events\"],\n            \"deprecated\": False,\n        },\n        list_route_info={\n            \"summary\": \"List all events\",\n            \"description\": \"Retrieves a paginated list of all events\",\n            \"tags\": [\"events\"],\n            \"schema_out\": CustomListSchema,\n        },\n        find_one_route_info={\n            \"summary\": \"Get event details\",\n            \"description\": \"Retrieves details of a specific event\",\n            \"tags\": [\"events\"],\n        }\n    )\n</code></pre>"},{"location":"api_controller/model_controller/02_model_configuration/#async-routes-configuration","title":"Async Routes Configuration","text":"<p>Enable async routes and configure async behavior:</p> <pre><code>@api_controller(\"/events\")\nclass AsyncEventModelController(ModelControllerBase):\n    model_config = ModelConfig(\n        model=Event,\n        # Async-specific configurations\n        async_routes=True,\n        schema_config=ModelSchemaConfig(\n            read_only_fields=[\"id\"],\n            depth=1\n        )\n    )\n\n    # Custom async service implementation\n    service = AsyncEventModelService(model=Event)\n</code></pre>"},{"location":"api_controller/model_controller/02_model_configuration/#configuration-inheritance","title":"Configuration Inheritance","text":"<p>ModelConfig also support configuration inheritance:</p> <pre><code>from ninja_extra.controllers import ModelConfig\n\nclass BaseModelConfig(ModelConfig):\n    async_routes = True\n    schema_config = ModelSchemaConfig(\n        read_only_fields=[\"id\", \"created_at\", \"updated_at\"],\n        depth=1\n    )\n\n@api_controller(\"/events\")\nclass EventModelController(ModelControllerBase):\n    model_config = BaseModelConfig(\n        model=Event,\n        # Override or extend base configuration\n        allowed_routes=[\"list\", \"find_one\"]\n    )\n</code></pre>"},{"location":"api_controller/model_controller/02_model_configuration/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Schema Configuration:</p> <ul> <li>Always specify <code>read_only_fields</code> for auto-generated fields</li> <li>Use <code>depth</code> carefully as it can impact performance</li> <li>Consider using <code>exclude</code> for sensitive fields</li> </ul> </li> <li> <p>Route Configuration:</p> <ul> <li>Limit <code>allowed_routes</code> to only necessary endpoints</li> <li>Provide meaningful summaries and descriptions</li> <li>Use tags for API organization</li> </ul> </li> <li> <p>Pagination:</p> <ul> <li>Always set reasonable limits</li> <li>Consider your data size when choosing pagination class</li> <li>Use appropriate page sizes for your use case</li> </ul> </li> <li> <p>Async Support:</p> <ul> <li>Enable <code>async_routes</code> when using async database operations</li> <li>Implement custom async services for complex operations</li> <li>Consider performance implications of async operations </li> </ul> </li> </ol>"},{"location":"api_controller/model_controller/03_model_service/","title":"Model Service","text":"<p>The Model Service layer in Ninja Extra handles all CRUD operations for your models. While the default implementation works well for simple cases, you can customize it for more complex scenarios.</p>"},{"location":"api_controller/model_controller/03_model_service/#default-model-service","title":"Default Model Service","text":"<p>The default <code>ModelService</code> implements both synchronous and asynchronous operations:</p> <pre><code>from ninja_extra.controllers.model.interfaces import ModelServiceBase, AsyncModelServiceBase\n\nclass ModelService(ModelServiceBase, AsyncModelServiceBase):\n    def __init__(self, model):\n        super().__init__(model=model)\n    ...\n</code></pre> <p>This provides the following methods:</p>"},{"location":"api_controller/model_controller/03_model_service/#synchronous-methods","title":"Synchronous Methods:","text":"<ul> <li><code>get_one(pk, **kwargs)</code> - Retrieve a single object</li> <li><code>get_all(**kwargs)</code> - Retrieve all objects</li> <li><code>create(schema, **kwargs)</code> - Create a new object</li> <li><code>update(instance, schema, **kwargs)</code> - Update an object</li> <li><code>patch(instance, schema, **kwargs)</code> - Partially update an object</li> <li><code>delete(instance, **kwargs)</code> - Delete an object</li> </ul>"},{"location":"api_controller/model_controller/03_model_service/#asynchronous-methods","title":"Asynchronous Methods:","text":"<ul> <li><code>get_one_async(pk, **kwargs)</code> - Async retrieve</li> <li><code>get_all_async(**kwargs)</code> - Async retrieve all</li> <li><code>create_async(schema, **kwargs)</code> - Async create</li> <li><code>update_async(instance, schema, **kwargs)</code> - Async update</li> <li><code>patch_async(instance, schema, **kwargs)</code> - Async patch</li> <li><code>delete_async(instance, **kwargs)</code> - Async delete</li> </ul>"},{"location":"api_controller/model_controller/03_model_service/#custom-model-service","title":"Custom Model Service","text":"<p>Here's how to create a custom service with additional business logic:</p> <pre><code>from typing import Any, List, Union\nfrom django.db.models import QuerySet\nfrom ninja_extra import ModelService\nfrom pydantic import BaseModel\n\nclass EventModelService(ModelService):\n    def get_one(self, pk: Any, **kwargs: Any) -&gt; Event:\n        # Add custom logic for retrieving an event\n        event = super().get_one(pk, **kwargs)\n        if not event.is_published and not kwargs.get('is_admin'):\n            raise PermissionError(\"Event not published\")\n        return event\n\n    def get_all(self, **kwargs: Any) -&gt; Union[QuerySet, List[Any]]:\n        # Filter events based on criteria\n        queryset = self.model.objects.all()\n        if not kwargs.get('is_admin'):\n            queryset = queryset.filter(is_published=True)\n        return queryset\n\n    def create(self, schema: BaseModel, **kwargs: Any) -&gt; Any:\n        # Add custom creation logic\n        data = schema.model_dump(by_alias=True)\n        data['created_by'] = kwargs.get('user_id')\n\n        instance = self.model._default_manager.create(**data)\n        return instance\n\n    def update(self, instance: Event, schema: BaseModel, **kwargs: Any) -&gt; Any:\n        # Add validation before update\n        if instance.is_locked:\n            raise ValueError(\"Cannot update locked event\")\n        return super().update(instance, schema, **kwargs)\n</code></pre>"},{"location":"api_controller/model_controller/03_model_service/#async-model-service","title":"Async Model Service","text":"<p>For async operations, you can customize the async methods:</p> <pre><code>from ninja_extra import ModelService\nfrom asgiref.sync import sync_to_async\n\n\nclass AsyncEventModelService(ModelService):\n    async def get_all_async(self, **kwargs: Any) -&gt; QuerySet:\n        # Custom async implementation\n        @sync_to_async\n        def get_filtered_events():\n            queryset = self.model.objects.all()\n            if kwargs.get('category'):\n                queryset = queryset.filter(category_id=kwargs['category'])\n            return queryset\n\n        return await get_filtered_events()\n\n    async def create_async(self, schema: BaseModel, **kwargs: Any) -&gt; Any:\n        # Custom async creation\n        @sync_to_async\n        def create_event():\n            data = schema.model_dump(by_alias=True)\n            data['created_by'] = kwargs.get('user_id')\n            return self.model._default_manager.create(**data)\n\n        return await create_event()\n</code></pre>"},{"location":"api_controller/model_controller/03_model_service/#using-custom-services","title":"Using Custom Services","text":"<p>Attach your custom service to your Model Controller:</p> <pre><code>@api_controller(\"/events\")\nclass EventModelController(ModelControllerBase):\n    service_type = EventModelService\n    model_config = ModelConfig(model=Event)\n</code></pre> <p>For async controllers:</p> <pre><code>@api_controller(\"/events\")\nclass AsyncEventModelController(ModelControllerBase):\n    service_type = AsyncEventModelService\n    model_config = ModelConfig(\n        model=Event,\n        async_routes=True\n    )\n</code></pre>"},{"location":"api_controller/model_controller/03_model_service/#advanced-service-patterns","title":"Advanced Service Patterns","text":""},{"location":"api_controller/model_controller/03_model_service/#service-with-dependency-injection","title":"Service with Dependency Injection","text":"<p>Model Services support dependency injection, allowing you to inject other services and dependencies when the controller is instantiated. Here's a practical example using email notifications and user tracking:</p> <p><pre><code>from datetime import datetime\nfrom typing import Any, Optional\nfrom django.core.mail import send_mail\nfrom ninja_extra import ModelService, api_controller, ModelConfig\nfrom pydantic import BaseModel\nfrom injector import inject\n\n\nclass EmailService:\n    \"\"\"Service for handling email notifications\"\"\"\n    def send_event_notification(self, event_data: dict, recipient_email: str):\n        subject = f\"Event Update: {event_data['title']}\"\n        message = (\n            f\"Event Details:\\n\"\n            f\"Title: {event_data['title']}\\n\"\n            f\"Date: {event_data['start_date']} to {event_data['end_date']}\\n\"\n        )\n        send_mail(\n            subject=subject,\n            message=message,\n            from_email=\"events@example.com\",\n            recipient_list=[recipient_email],\n            fail_silently=False,\n        )\n\n\nclass UserActivityService:\n    \"\"\"Service for tracking user activities\"\"\"\n    def track_activity(self, user_id: int, action: str, details: dict):\n        UserActivity.objects.create(\n            user_id=user_id,\n            action=action,\n            details=details,\n            timestamp=datetime.now()\n        )\n</code></pre> Creating <code>EventModelService</code> with <code>EmailService</code> and <code>UserActivityService</code> as dependencies. <pre><code>class EventModelService(ModelService):\n    \"\"\"\n    Event service with email notifications and activity tracking.\n    Dependencies are automatically injected by the framework.\n    \"\"\"\n    @inject\n    def __init__(\n        self, \n        model: Event,\n        email_service: EmailService,\n        activity_service: UserActivityService\n    ):\n        super().__init__(model=model)\n        self.email_service = email_service\n        self.activity_service = activity_service\n\n    def create(self, schema: BaseModel, **kwargs: Any) -&gt; Any:\n        # Create the event\n        event = super().create(schema, **kwargs)\n\n        # Track the creation activity\n        if user_id := kwargs.get('user_id'):\n            self.activity_service.track_activity(\n                user_id=user_id,\n                action=\"event_created\",\n                details={\n                    \"event_id\": event.id,\n                    \"title\": event.title\n                }\n            )\n\n        # Send notification to organizer\n        if organizer_email := kwargs.get('organizer_email'):\n            self.email_service.send_event_notification(\n                event_data=schema.model_dump(),\n                recipient_email=organizer_email\n            )\n\n        return event\n\n    def update(self, instance: Event, schema: BaseModel, **kwargs: Any) -&gt; Any:\n        # Update the event\n        updated_event = super().update(instance, schema, **kwargs)\n\n        # Track the update activity\n        if user_id := kwargs.get('user_id'):\n            self.activity_service.track_activity(\n                user_id=user_id,\n                action=\"event_updated\",\n                details={\n                    \"event_id\": updated_event.id,\n                    \"title\": updated_event.title,\n                    \"changes\": schema.model_dump()\n                }\n            )\n\n        # Notify relevant parties about the update\n        if notify_participants := kwargs.get('notify_participants'):\n            for participant in updated_event.participants.all():\n                self.email_service.send_event_notification(\n                    event_data=schema.model_dump(),\n                    recipient_email=participant.email\n                )\n\n        return updated_event\n\n    def delete(self, instance: Event, **kwargs: Any) -&gt; Any:\n        event_data = {\n            \"id\": instance.id,\n            \"title\": instance.title\n        }\n\n        # Delete the event\n        super().delete(instance, **kwargs)\n\n        # Track the deletion\n        if user_id := kwargs.get('user_id'):\n            self.activity_service.track_activity(\n                user_id=user_id,\n                action=\"event_deleted\",\n                details=event_data\n            )\n\n        # Notify participants about cancellation\n        if notify_participants := kwargs.get('notify_participants'):\n            for participant in instance.participants.all():\n                self.email_service.send_event_notification(\n                    event_data={\n                        **event_data,\n                        \"message\": \"Event has been cancelled\"\n                    },\n                    recipient_email=participant.email\n                )\n</code></pre></p> <p>Creating <code>EventModelController</code> with <code>EventModelService</code> as the service. <pre><code>from ninja_extra.controllers import ModelEndpointFactory, ModelControllerBase, ModelConfig\nfrom ninja_extra import api_controller\n\n@api_controller(\"/events\")\nclass EventModelController(ModelControllerBase):\n    service_type = EventModelService\n    model_config = ModelConfig(model=Event, allowed_routes=['find_one', 'list'])\n\n    create_new_event = ModelEndpointFactory.create(\n        path=\"/?organizer_email=str\",\n        schema_in=model_config.create_schema,\n        schema_out=model_config.retrieve_schema,\n        custom_handler=lambda self, data, **kw: self.service.create(data, **kw)\n    )\n\n    update_event = ModelEndpointFactory.update(\n        path=\"/{int:event_id}/?notify_participants=str\",\n        lookup_param=\"event_id\",\n        schema_in=model_config.update_schema,\n        schema_out=model_config.retrieve_schema,\n        object_getter=lambda self, pk, **kw: self.get_object_or_exception(self.model_config.model, pk=pk),\n        custom_handler=lambda self, **kw: self.service.update(**kw),\n    )\n</code></pre> Register the services in the injector module <pre><code>from injector import Module, singleton\n\n\nclass EventModule(Module):\n    def configure(self, binder):\n        binder.bind(EmailService, to=EmailService, scope=singleton)\n        binder.bind(UserActivityService, to=UserActivityService, scope=singleton)\n\n## settings.py\n```python\nNINJA_EXTRA = {\n    'INJECTOR_MODULES': [\n        'your_app.injector_module.EventModule'\n    ]\n}\n</code></pre></p> <p>The injected services provide several benefits:</p> <ul> <li>Automatic email notifications when events are created/updated/deleted</li> <li>User activity tracking for audit trails</li> <li>Clean separation of business logic</li> <li>Easy to extend with additional services</li> <li>Testable components with clear dependencies</li> </ul> <p>For more information on dependency injection, please refer to the Dependency Injection page.</p>"},{"location":"api_controller/model_controller/04_parameters/","title":"Path and Query Parameters","text":"<p>Model Controllers in Ninja Extra provide flexible ways to handle path and query parameters in your API endpoints when using the <code>ModelEndpointFactory</code>. This guide covers how to work with these parameters effectively. </p> <p>Note: This guide is only useful if you are using a Custom <code>ModelService</code> and you are not interested in adding additional logic to the route handler.</p>"},{"location":"api_controller/model_controller/04_parameters/#basic-path-parameters","title":"Basic Path Parameters","text":"<p>Path parameters are part of the URL path and are typically used to identify specific resources:</p> <pre><code>from ninja_extra import ModelEndpointFactory, ModelControllerBase\n\n@api_controller(\"/events\")\nclass EventModelController(ModelControllerBase):\n    # Basic path parameter for event ID\n    get_event = ModelEndpointFactory.find_one(\n        path=\"/{int:id}\",  # int converter for ID\n        lookup_param=\"id\",\n        schema_out=EventSchema\n    )\n</code></pre> <p><code>lookup_param</code> is the name of the parameter in the model that will be used to lookup the object.</p>"},{"location":"api_controller/model_controller/04_parameters/#path-parameter-types","title":"Path Parameter Types","text":"<p>The following parameter types are supported:</p> <pre><code>@api_controller(\"/events\")\nclass EventModelController(ModelControllerBase):\n    # Integer parameter\n    get_by_id = ModelEndpointFactory.find_one(\n        path=\"/{int:id}\",\n        lookup_param=\"id\",\n        schema_out=EventSchema\n    )\n\n    # String parameter\n    get_by_slug = ModelEndpointFactory.find_one(\n        path=\"/{str:slug}\",\n        lookup_param=\"slug\",\n        schema_out=EventSchema\n    )\n\n    # UUID parameter\n    get_by_uuid = ModelEndpointFactory.find_one(\n        path=\"/{uuid:uuid}\",\n        lookup_param=\"uuid\",\n        schema_out=EventSchema\n    )\n\n    # Date parameter\n    get_by_date = ModelEndpointFactory.find_one(\n        path=\"/{date:event_date}\",\n        lookup_param=\"event_date\",\n        schema_out=EventSchema\n    )\n</code></pre>"},{"location":"api_controller/model_controller/04_parameters/#query-parameters","title":"Query Parameters","text":"<p>Query parameters are added to the URL after the <code>?</code> character and are useful for filtering, sorting, and pagination:</p> <pre><code>from typing import Optional\nfrom ninja_extra import ModelEndpointFactory\n\n@api_controller(\"/events\")\nclass EventModelController(ModelControllerBase):\n    # Endpoint with query parameters\n    list_events = ModelEndpointFactory.list(\n        path=\"/?category=int&amp;status=str\",  # Define query parameters\n        schema_out=EventSchema,\n        queryset_getter=lambda self, **kwargs: self.get_filtered_events(**kwargs)\n    )\n\n    def get_filtered_events(self, category: Optional[int] = None, \n                          status: Optional[str] = None, **kwargs):\n        queryset = self.model.objects.all()\n\n        if category:\n            queryset = queryset.filter(category_id=category)\n        if status:\n            queryset = queryset.filter(status=status)\n\n        return queryset\n</code></pre>"},{"location":"api_controller/model_controller/04_parameters/#combining-path-and-query-parameters","title":"Combining Path and Query Parameters","text":"<p>You can combine both types of parameters in a single endpoint:</p> <pre><code>class EventQueryParamsModelService(ModelService):\n    def get_category_events(\n        self, \n        category_id: int, \n        status: Optional[str] = None, \n        date: Optional[date] = None, \n        **kwargs\n    ):\n        queryset = self.model.objects.filter(category_id=category_id)\n        if status:\n            queryset = queryset.filter(status=status)\n        if date:\n            queryset = queryset.filter(start_date=date)\n        return queryset\n\n@api_controller(\"/events\")\nclass EventModelController(ModelControllerBase):\n    service = EventQueryParamsModelService(model=Event)\n    # Path and query parameters together\n    get_category_events = ModelEndpointFactory.list(\n        path=\"/{int:category_id}/events?status=str&amp;date=date\",\n        schema_out=EventSchema,\n        queryset_getter=lambda self, **kwargs: self.service.get_category_events(**kwargs)\n    )\n</code></pre>"},{"location":"api_controller/model_controller/04_parameters/#custom-parameter-handling","title":"Custom Parameter Handling","text":"<p>You can implement custom parameter handling using object getters:</p> <pre><code>class CustomParamsModelService(ModelService):\n    def get_by_slug(self, slug: str) -&gt; Event:\n        return self.model.objects.get(slug=slug)\n\n\n@api_controller(\"/events\")\nclass EventModelController(ModelControllerBase):\n    service = CustomParamsModelService(model=Event)\n    get_event = ModelEndpointFactory.find_one(\n        path=\"/{str:slug}\",\n        lookup_param=\"slug\",\n        schema_out=EventSchema,\n        object_getter=lambda self, slug, **kwargs: self.service.get_by_slug(slug)\n    )\n</code></pre>"},{"location":"api_controller/model_controller/04_parameters/#async-parameter-handling","title":"Async Parameter Handling","text":"<p>For async controllers, parameter handling works similarly:</p> <pre><code>class AsyncCustomParamsModelService(ModelService):\n    async def get_filtered_events(self, **kwargs):\n        @sync_to_async\n        def get_events():\n            queryset = self.model.objects.all()\n\n            if kwargs.get('category'):\n                queryset = queryset.filter(category_id=kwargs['category'])\n            if kwargs.get('status'):\n                queryset = queryset.filter(status=kwargs['status'])\n\n            return queryset\n\n        return await get_events()\n\n@api_controller(\"/events\")\nclass AsyncEventModelController(ModelControllerBase):\n    service_type = AsyncCustomParamsModelService\n    model_config = ModelConfig(\n        model=Event,\n        async_routes=True\n    )\n\n    list_events = ModelEndpointFactory.list(\n        path=\"/?category=int&amp;status=str\",\n        schema_out=EventSchema,\n        queryset_getter=lambda self, **kwargs: self.service.get_filtered_events(**kwargs)\n    )\n</code></pre>"},{"location":"api_controller/model_controller/04_parameters/#parameter-validation","title":"Parameter Validation","text":"<p>You can add validation to your parameters using Pydantic models:</p> <pre><code>from datetime import date\nfrom typing import Optional\nfrom pydantic import BaseModel, Field\n\nclass EventQueryParams(BaseModel):\n    category_id: Optional[int] = None\n    status: Optional[str] = Field(None, pattern=\"^(active|inactive|draft)$\")\n    date_from: Optional[date] = None\n    date_to: Optional[date] = None\n\n\nclass EventQueryParamsModelService(ModelService):\n    def get_filtered_events(self, params: EventQueryParams):\n        queryset = self.model.objects.all()\n\n        if params.category_id:\n            queryset = queryset.filter(category_id=params.category_id)\n        if params.status:\n            queryset = queryset.filter(status=params.status)\n        if params.date_from:\n            queryset = queryset.filter(start_date__gte=params.date_from)\n        if params.date_to:\n            queryset = queryset.filter(end_date__lte=params.date_to)\n\n        return queryset\n\n\n@api_controller(\"/events\")\nclass EventModelController(ModelControllerBase):\n    service_type = EventQueryParamsModelService\n    model_config = ModelConfig(\n        model=Event,\n        async_routes=True\n    )\n\n    list_events = ModelEndpointFactory.list(\n        path=\"/\",\n        schema_in=EventQueryParams,\n        schema_out=EventSchema,\n        queryset_getter=lambda self, query: self.service.get_filtered_events(query)\n    )\n</code></pre>"},{"location":"dependency-injection/","title":"Dependency Injection in Controllers","text":"<p>Django Ninja Extra provides powerful dependency injection capabilities using Injector. This guide will show you how to effectively use dependency injection in your controllers.</p>"},{"location":"dependency-injection/#basic-example","title":"Basic Example","text":"<p>Let's start with a simple example of dependency injection in a controller:</p> <pre><code>from ninja_extra import api_controller, http_get\nfrom injector import inject\n\nclass UserService:\n    def get_user_count(self) -&gt; int:\n        return 42  # Example implementation\n\n@api_controller(\"/users\")\nclass UserController:\n    @inject\n    def __init__(self, user_service: UserService):  # Type annotation is required\n        self.user_service = user_service\n\n    @http_get(\"/count\")\n    def get_count(self):\n        return {\"count\": self.user_service.get_user_count()}\n</code></pre>"},{"location":"dependency-injection/#real-world-example-todo-application","title":"Real-World Example: Todo Application","text":"<p>Let's create a more practical example with a Todo application that demonstrates dependency injection with multiple services.</p>"},{"location":"dependency-injection/#1-define-the-services","title":"1. Define the Services","text":"<pre><code>from typing import List, Optional\nfrom datetime import datetime\nfrom pydantic import BaseModel\nfrom injector import inject\n\n# Data Models\nclass TodoItem(BaseModel):\n    id: int\n    title: str\n    completed: bool = False\n    created_at: datetime\n\n# Repository Service\nclass TodoRepository:\n    def __init__(self):\n        self._todos: List[TodoItem] = []\n        self._counter = 0\n\n    def add(self, title: str) -&gt; TodoItem:\n        self._counter += 1\n        todo = TodoItem(\n            id=self._counter,\n            title=title,\n            created_at=datetime.now()\n        )\n        self._todos.append(todo)\n        return todo\n\n    def get_all(self) -&gt; List[TodoItem]:\n        return self._todos\n\n    def get_by_id(self, todo_id: int) -&gt; Optional[TodoItem]:\n        return next((todo for todo in self._todos if todo.id == todo_id), None)\n\n    def toggle_complete(self, todo_id: int) -&gt; Optional[TodoItem]:\n        todo = self.get_by_id(todo_id)\n        if todo:\n            todo.completed = not todo.completed\n        return todo\n\n# Business Logic Service\nclass TodoService:\n    @inject\n    def __init__(self, repository: TodoRepository):\n        self.repository = repository\n\n    def create_todo(self, title: str) -&gt; TodoItem:\n        return self.repository.add(title)\n\n    def get_todos(self) -&gt; List[TodoItem]:\n        return self.repository.get_all()\n\n    def toggle_todo(self, todo_id: int) -&gt; Optional[TodoItem]:\n        return self.repository.toggle_complete(todo_id)\n</code></pre>"},{"location":"dependency-injection/#2-create-the-controller","title":"2. Create the Controller","text":"<pre><code>from ninja_extra import api_controller, http_get, http_post, http_put\nfrom ninja import Body\n\n# Request Models\nclass CreateTodoRequest(BaseModel):\n    title: str\n\n@api_controller(\"/todos\")\nclass TodoController:\n    def __init__(self, todo_service: TodoService):\n        self.todo_service = todo_service\n\n    @http_post(\"\")\n    def create_todo(self, request: CreateTodoRequest = Body(...)):\n        todo = self.todo_service.create_todo(request.title)\n        return todo\n\n    @http_get(\"\")\n    def list_todos(self):\n        return self.todo_service.get_todos()\n\n    @http_put(\"/{todo_id}/toggle\")\n    def toggle_todo(self, todo_id: int):\n        todo = self.todo_service.toggle_todo(todo_id)\n        if not todo:\n            return {\"error\": \"Todo not found\"}, 404\n        return todo\n</code></pre> <p>Warning</p> <p>You are not allowed to override your APIController constructor with parameters that don't have type annotations. The following example demonstrates the correct way to use type annotations in your constructor. Read more Python Injector </p>"},{"location":"dependency-injection/#3-register-the-services","title":"3. Register the Services","text":"<p>Create a module to register your services. When registering services, you can specify their scope:</p> <ul> <li><code>singleton</code>: The service is created once and reused (default). Best for stateless services or services that maintain application-wide state.</li> <li><code>noscope</code> (transient): A new instance is created each time the service is requested. Best for services that maintain request-specific state.</li> </ul> <pre><code>from injector import Module, singleton, noscope, Binder\n\nclass TodoModule(Module):\n    def configure(self, binder: Binder) -&gt; None:\n        # Singleton scope - same instance for entire application\n        # TodoRepository maintains application state (the todos list)\n        binder.bind(TodoRepository, to=TodoRepository, scope=singleton)\n\n        # Singleton scope - stateless service that only contains business logic\n        binder.bind(TodoService, to=TodoService, scope=singleton)\n\n        # Example of when to use noscope\n        # binder.bind(RequestContextService, to=RequestContextService, scope=noscope)\n</code></pre> <p>Info</p> <p>If no scope is specified, services default to <code>singleton</code> scope. Choose the appropriate scope based on your service's requirements:</p> <ul> <li>Use <code>singleton</code> for:<ul> <li>Stateless services (like services that only contain business logic)</li> <li>Services that maintain application-wide state</li> <li>Services that are expensive to create</li> </ul> </li> <li>Use <code>noscope</code> for:<ul> <li>Services that maintain request-specific state</li> <li>Services that need to be recreated for each request</li> <li>Services with request-scoped dependencies</li> </ul> </li> </ul>"},{"location":"dependency-injection/#4-configure-settings","title":"4. Configure Settings","text":"<p>Add the module to your Django settings:</p> <pre><code>NINJA_EXTRA = {\n    'INJECTOR_MODULES': [\n        'your_app.modules.TodoModule'\n    ]\n}\n</code></pre> <p>Info</p> <p>Django-Ninja-Extra supports django_injector. If you're using django_injector, no additional configuration is needed in settings.py.</p>"},{"location":"dependency-injection/#5-register-the-api","title":"5. Register the API","text":"<pre><code>from ninja_extra import NinjaExtraAPI\n\napi = NinjaExtraAPI()\napi.register_controllers(TodoController)\n</code></pre>"},{"location":"dependency-injection/#advanced-usage-multiple-dependencies","title":"Advanced Usage: Multiple Dependencies","text":"<p>You can inject multiple services into a controller:</p> <pre><code>from ninja_extra import api_controller, http_get\nfrom injector import inject\n\nclass AuthService:\n    def is_admin(self) -&gt; bool:\n        return True  # Example implementation\n\nclass LoggingService:\n    def log_access(self, endpoint: str):\n        print(f\"Accessed: {endpoint}\")  # Example implementation\n\n@api_controller(\"/admin\")\nclass AdminController:\n    def __init__(\n        self, \n        auth_service: AuthService,\n        logging_service: LoggingService,\n        todo_service: TodoService\n    ):\n        self.auth_service = auth_service\n        self.logging_service = logging_service\n        self.todo_service = todo_service\n\n    @http_get(\"/todos\")\n    def get_todos(self):\n        if not self.auth_service.is_admin():\n            return {\"error\": \"Unauthorized\"}, 403\n\n        self.logging_service.log_access(\"admin/todos\")\n        return self.todo_service.get_todos()\n</code></pre>"},{"location":"dependency-injection/#using-service-resolver","title":"Using Service Resolver","text":"<p>Sometimes you might need to resolve services outside of controllers. Django Ninja Extra provides a <code>service_resolver</code> utility for this:</p> <pre><code>from ninja_extra import service_resolver\n\n# Resolve a single service\ntodo_service = service_resolver(TodoService)\ntodos = todo_service.get_todos()\n\n# Resolve multiple services\ntodo_service, auth_service = service_resolver(TodoService, AuthService)\n</code></pre>"},{"location":"dependency-injection/#best-practices","title":"Best Practices","text":"<ol> <li>Single Responsibility: Keep your services focused on a single responsibility.</li> <li>Interface Segregation: Create specific interfaces for your services rather than large, monolithic ones.</li> <li>Dependency Inversion: Depend on abstractions rather than concrete implementations.</li> <li>Scoping: Use appropriate scopes for your services:<ul> <li>Use <code>singleton</code> for services that maintain application-wide state</li> <li>Use <code>noscope</code> (transient) for services that should be created per request</li> </ul> </li> </ol>"},{"location":"dependency-injection/#testing-with-dependency-injection","title":"Testing with Dependency Injection","text":"<p>Testing applications that use dependency injection requires special consideration for mocking services and managing test environments. We have a dedicated guide that covers all aspects of testing, including:</p> <ul> <li>Setting up separate development and testing environments</li> <li>Implementing mock services</li> <li>Using different testing frameworks (pytest, NinjaExtra TestClient)</li> <li>Best practices for test configuration</li> <li>Managing service dependencies in tests</li> </ul> <p>For the complete guide on testing with dependency injection, see Testing with Dependency Injection.</p>"},{"location":"dependency-injection/testing/","title":"Testing with Dependency Injection","text":"<p>This guide explains best practices for testing applications that use dependency injection in Django Ninja Extra.</p>"},{"location":"dependency-injection/testing/#settings-configuration-for-testing","title":"Settings Configuration for Testing","text":"<p>A recommended approach is to maintain separate Django settings files for development and testing. This allows you to swap out real services with mock implementations during testing.</p>"},{"location":"dependency-injection/testing/#project-structure","title":"Project Structure","text":"<pre><code>your_project/\n\u251c\u2500\u2500 config/\n\u2502   \u251c\u2500\u2500 settings/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 base.py\n\u2502   \u2502   \u251c\u2500\u2500 development.py\n\u2502   \u2502   \u2514\u2500\u2500 testing.py\n\u251c\u2500\u2500 your_app/\n\u2502   \u251c\u2500\u2500 services/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 todo_service.py\n\u2502   \u2502   \u2514\u2500\u2500 mock_todo_service.py\n\u2502   \u2514\u2500\u2500 modules.py\n</code></pre>"},{"location":"dependency-injection/testing/#development-settings-developmentpy","title":"Development Settings (development.py)","text":"<pre><code>from .base import *\n\nNINJA_EXTRA = {\n    'INJECTOR_MODULES': [\n        'your_app.modules.TodoModule'  # Uses real implementation\n    ]\n}\n</code></pre>"},{"location":"dependency-injection/testing/#testing-settings-testingpy","title":"Testing Settings (testing.py)","text":"<pre><code>from .base import *\n\nNINJA_EXTRA = {\n    'INJECTOR_MODULES': [\n        'your_app.modules.MockTodoModule'  # Uses mock implementation\n    ]\n}\n</code></pre>"},{"location":"dependency-injection/testing/#implementing-mock-services","title":"Implementing Mock Services","text":"<p>Create your mock services and module:</p> <pre><code># your_app/services/mock_todo_service.py\nfrom typing import List, Optional\nfrom datetime import datetime\nfrom .todo_service import TodoItem, TodoService\n\nclass MockTodoRepository:\n    def __init__(self):\n        self._todos = [\n            TodoItem(id=1, title=\"Test Todo\", completed=False, created_at=datetime.now())\n        ]\n\n    def get_all(self) -&gt; List[TodoItem]:\n        return self._todos\n\n    def get_by_id(self, todo_id: int) -&gt; Optional[TodoItem]:\n        return self._todos[0] if todo_id == 1 else None\n\n    def add(self, title: str) -&gt; TodoItem:\n        return self._todos[0]\n\n    def toggle_complete(self, todo_id: int) -&gt; Optional[TodoItem]:\n        todo = self.get_by_id(todo_id)\n        if todo:\n            todo.completed = not todo.completed\n        return todo\n\n# your_app/modules.py\nfrom injector import Module, singleton, Binder\nfrom .services.mock_todo_service import MockTodoRepository\nfrom .services.todo_service import TodoService, TodoRepository\n\nclass MockTodoModule(Module):\n    def configure(self, binder: Binder) -&gt; None:\n        binder.bind(TodoRepository, to=MockTodoRepository, scope=singleton)\n        binder.bind(TodoService, to=TodoService, scope=singleton)\n</code></pre>"},{"location":"dependency-injection/testing/#running-tests","title":"Running Tests","text":"<p>After setting up your mock services and configuring your test environment, you can write tests using for the controller using the <code>TestClient</code> from <code>ninja_extra.testing</code>. As shown in the example below:</p> <pre><code># tests/test_todo_api.py\nimport pytest\nfrom ninja_extra import testing\nfrom your_app.controllers import TodoController\n\n@pytest.mark.django_db\nclass TestTodoController:\n    def test_list_todos(self):\n        client = testing.TestClient(TodoController)\n        response = client.get(\"/api/todos\")\n\n        assert response.status_code == 200\n        data = response.json()\n\n        assert len(data) == 1\n        assert data[0][\"title\"] == \"Test Todo\"\n\n    def test_create_todo(self):\n        client = testing.TestClient(TodoController)\n        response = client.post(\"/api/todos\", {\"title\": \"New Todo\"})\n\n        assert response.status_code == 200\n        data = response.json()\n\n        assert data[\"title\"] == \"Test Todo\"  # Returns mock data\n</code></pre>"},{"location":"dependency-injection/testing/#best-practices","title":"Best Practices","text":"<ol> <li>Separate Settings Files: Maintain separate settings files for different environments (development, testing, production).</li> <li>Mock Module Design: <ul> <li>Keep mock implementations simple but sufficient for testing</li> <li>Implement only the methods that are actually used in tests</li> <li>Use predictable, static data in mock responses</li> </ul> </li> <li>Test Data: <ul> <li>Initialize mock services with known test data</li> <li>Avoid dependencies on external services in tests</li> </ul> </li> <li>Configuration Management:<ul> <li>Use environment variables to switch between settings files</li> <li>Document the required environment setup for running tests</li> </ul> </li> </ol>"},{"location":"dependency-injection/testing/#environment-setup","title":"Environment Setup","text":"<p>To use different settings files, set the Django settings module environment variable:</p> <pre><code># For development\nexport DJANGO_SETTINGS_MODULE=config.settings.development\n\n# For testing\nexport DJANGO_SETTINGS_MODULE=config.settings.testing\n</code></pre> <p>Or in pytest.ini: <pre><code>[pytest]\nDJANGO_SETTINGS_MODULE = config.settings.testing\n</code></pre></p> <p>This approach ensures consistent and isolated testing environments while maintaining the ability to use real implementations in development. </p>"},{"location":"tutorial/","title":"Tutorial / Reference","text":"<p>This tutorial shows you how to use Django Ninja Extra with most of its features.  And most especially assumes you know how to use Django Ninja</p> <p>Info</p> <p>A lot of content here is drawn from Django-Ninja. So a lot would make sense if you understand the Django-Ninja framework first.</p>"},{"location":"tutorial/#installation","title":"Installation","text":"<pre><code>pip install django-ninja-extra\n</code></pre> <p>After installation, add <code>ninja_extra</code> to your <code>INSTALLED_APPS</code></p> <pre><code>INSTALLED_APPS = [\n    ...,\n    'ninja_extra',\n]\n</code></pre>"},{"location":"tutorial/#create-a-django-project","title":"Create a Django project","text":"<p>(If you already have an existing Django project, skip to the next step).</p> <p>Start a new Django project (or use an existing one).</p> <pre><code>django-admin startproject myproject\n</code></pre>"},{"location":"tutorial/#first-steps","title":"First steps","text":"<p>Let's create a module for our API.  Create an api.py file in the same directory location as urls.py:</p> <p><code>api.py</code></p> <pre><code>from ninja_extra import NinjaExtraAPI\n\napi = NinjaExtraAPI()\n\n# function definition using Django-Ninja default router\n@api.get(\"/hello\")\ndef hello(request):\n    return \"Hello world\"\n</code></pre> <p>Now go to urls.py and add the following:</p> <pre><code>from django.contrib import admin\nfrom django.urls import path\nfrom .api import api\n\nurlpatterns = [\n    path(\"admin/\", admin.site.urls),\n    path(\"api/\", api.urls),\n]\n</code></pre>"},{"location":"tutorial/#defining-operation-methods","title":"Defining operation methods","text":"<p>\"Operation\" can be one of the HTTP \"methods\":</p> <ul> <li>GET</li> <li>POST</li> <li>PUT</li> <li>DELETE</li> <li>PATCH</li> <li>... and more.</li> </ul> <p>These are Django-Ninja defined operations on the API or Django-Ninja router.  The same operation is exposed to APIControllers with the <code>route</code> class.  The <code>route</code> class is an extra decorator that converts APIController instance methods to route function or endpoint.</p> <p>On the other hand, the <code>router</code> here is a short form of the <code>ControllerRouter</code> class,  an adapter class, which is an that only adapts APIController to the Django-Ninja router. It also provides global control of all routes defined in any APIController class. <pre><code>from ninja_extra import (\n    api_controller, \n    http_get, http_post, http_put, http_delete, http_patch, http_generic\n)\nfrom ninja.constants import NOT_SET\n\n@api_controller('', tags=['My Operations'], auth=NOT_SET, permissions=[])\nclass MyAPIController:\n    @http_get(\"/path\")\n    def get_operation(self):\n        ...\n\n    @http_post(\"/path\")\n    def post_operation(self):\n        ...\n\n    @http_put(\"/path\")\n    def put_operation(self):\n        ...\n\n    @http_delete(\"/path\")\n    def delete_operation(self):\n        ...\n\n    @http_patch(\"/path\")\n    def patch_operation(self):\n        ...\n\n    # If you need to handle multiple methods with a single function, you can use the `generic` method as shown above\n    @http_generic([\"POST\", \"PATCH\"]) \n    def mixed(request):\n        ...\n\napi.register_controllers(MyAPIController)\n</code></pre> To have a complete Controller setup, the APIController must be decorated with <code>ControllerRouter</code> before it's been registered.</p>"},{"location":"tutorial/authentication/","title":"Authentication","text":"<p>Django Ninja Extra offers the same API for authorization and authentication as in Django Ninja, ensuring consistency and ease of use across both packages.</p>"},{"location":"tutorial/authentication/#automatic-openapi-schema","title":"Automatic OpenAPI schema","text":"<p>Here's an example where the client, in order to authenticate, needs to pass a header:</p> <p><code>Authorization: Bearer supersecret</code></p> <pre><code>from ninja.security import HttpBearer\nfrom ninja_extra import api_controller, route\nfrom ninja.constants import NOT_SET\n\n\nclass AuthBearer(HttpBearer):\n    def authenticate(self, request, token):\n        if token == \"supersecret\":\n            return token\n\n@api_controller(tags=['My Operations'], auth=NOT_SET, permissions=[])\nclass MyController:\n    @route.get(\"/bearer\", auth=AuthBearer())\n    def bearer(self):\n        return {\"token\": self.context.request.auth}\n</code></pre>"},{"location":"tutorial/authentication/#global-authentication","title":"Global authentication","text":"<p>In case you need to secure all route methods defined in <code>api</code> and APIController, you can pass the <code>auth</code> argument to the <code>NinjaExtraAPI</code> constructor:</p> <p><pre><code>from ninja_extra import NinjaExtraAPI\nfrom ninja.security import HttpBearer\n\n\nclass GlobalAuth(HttpBearer):\n    def authenticate(self, request, token):\n        if token == \"supersecret\":\n            return token\n\n\napi = NinjaExtraAPI(auth=GlobalAuth())\n</code></pre> Read more on django-ninja authentication</p>"},{"location":"tutorial/authentication/#asynchronous-auth-classes","title":"Asynchronous Auth Classes","text":"<p>Ninja Extra added Asynchronous support for all <code>Auth</code> base classes provided by Django Ninja in <code>ninja_extra.security</code> package. And it maintained similar interface. It is important to noted that when using these asynchronous auth classes, the endpoint handler  must asynchronous functions.</p> <p>For example, lets re-write the first auth example with <code>AsyncHttpBearer</code> class.</p> <p><pre><code>from ninja_extra import api_controller, route\nfrom ninja_extra.security import AsyncHttpBearer\nfrom ninja.constants import NOT_SET\n\n\nclass AuthBearer(AsyncHttpBearer):\n    async def authenticate(self, request, token):\n        # await some actions\n        if token == \"supersecret\":\n            return token\n\n\n@api_controller(tags=['My Operations'], auth=NOT_SET, permissions=[])\nclass MyController:\n    @route.get(\"/bearer\", auth=AuthBearer())\n    async def bearer(self):\n        return {\"token\": self.context.request.auth}\n</code></pre> In example above, we changed <code>HttpBearer</code> to <code>AsyncHttpBearer</code> and changed bearer to <code>async</code> endpoint.  If <code>AuthBearer</code> is to be applied to a <code>MyController</code> auth, then all route handlers under <code>MyController</code> must be asynchronous route handlers.</p>"},{"location":"tutorial/authentication/#jwt-authentication","title":"JWT Authentication","text":"<p>if you want to use JWT authentication. See ninja-jwt</p>"},{"location":"tutorial/body_request/","title":"Request Body","text":"<p>Request bodies are typically used with \u201ccreate\u201d and \u201cupdate\u201d operations (POST, PUT, PATCH). For example, when creating a resource using POST or PUT, the request body usually contains the representation of the resource to be created.</p> <p>To declare a request body, you need to use Django Ninja <code>Schema</code> or any Pydantic Schema that suits your need.</p> <p>I recommend Ninja-Schema</p>"},{"location":"tutorial/body_request/#create-your-data-model","title":"Create your data model","text":"<p>Then you declare your data model as a class that inherits from <code>Schema</code>.</p> <p>Use standard Python types for all the attributes:</p> <pre><code>from ninja import Schema, constants\nfrom ninja_extra import api_controller, route\n\n\nclass Item(Schema):\n    name: str\n    description: str = None\n    price: float\n    quantity: int\n\n\n@api_controller(tags=['My Operations'], auth=constants.NOT_SET, permissions=[])\nclass MyAPIController:\n    @route.post(\"/items\")\n    def create(self, item: Item):\n        return item\n</code></pre> <p>Note: if you use <code>None</code> as the default value for an attribute, it will become optional in the request body. For example, this model above declares a JSON \"<code>object</code>\" (or Python <code>dict</code>) like:</p> <pre><code>{\n    \"name\": \"Katana\",\n    \"description\": \"An optional description\",\n    \"price\": 299.00,\n    \"quantity\": 10\n}\n</code></pre> <p>...as <code>description</code> is optional (with a default value of <code>None</code>), this JSON \"<code>object</code>\" would also be valid:</p> <pre><code>{\n    \"name\": \"Katana\",\n    \"price\": 299.00,\n    \"quantity\": 10\n}\n</code></pre>"},{"location":"tutorial/custom_exception/","title":"Custom Exception","text":"<p>Django-Ninja provides an intuitive way of handling custom exceptions by registering a function(handler) against an Exception type, just like it's done in a Flask app.</p> <p>So in that sense, Django-Ninja-Extra has an <code>APIException</code> exception type which provides similar functionalities, for those use to DRF <code>APIException</code>.</p> <p>For Example:  <pre><code>from ninja_extra.exceptions import APIException\nfrom ninja_extra import api_controller, route, NinjaExtraAPI, status\nfrom ninja import constants\n\n\nclass CustomAPIException(APIException):\n    status_code = status.HTTP_401_UNAUTHORIZED\n    default_detail = 'UnAuthorized'\n\n\n@api_controller('', tags=['My Operations'], auth=constants.NOT_SET, permissions=[])\nclass MyController:\n    @route.get('/exception')\n    def custom_exception(self):\n        raise CustomAPIException()\n\n\napi = NinjaExtraAPI(title='Exception Test')\napi.register_controllers(MyController)\n</code></pre> </p>"},{"location":"tutorial/form/","title":"Form Request","text":"<p>If you are not sure how to make a form post request like <code>application/x-www-form-urlencode</code> or <code>multipart/form-data</code> in django-ninja-extra, then this guide would be useful for you. Django-Ninja already covers most of the use cases here, but I will give you a quick summary here.</p>"},{"location":"tutorial/form/#form-data-as-params","title":"Form Data as Params","text":"<p><pre><code>from ninja import Form, constants\nfrom ninja_extra import api_controller, http_post, router\n\n\n@api_controller('', tags=['My Operations'], auth=constants.NOT_SET, permissions=[])\nclass MyAPIController:\n    @http_post(\"/login\")\n    def login(self, username: str = Form(...), password: str = Form(...)):\n        return {'username': username, 'password': '*****'}\n</code></pre> Two things to note here:</p> <ul> <li>You need to import <code>Form</code> from <code>ninja</code> module</li> <li>Use <code>Form</code> as default value for your parameter</li> </ul> <p>Info</p> <p>For more information on this, visit Django-Ninja Form tutorial</p>"},{"location":"tutorial/ordering/","title":"Ordering","text":"<p>Django Ninja Extra provides an intuitive ordering model using <code>ordering</code> decoration from the Django-Ninja-Extra ordering module. It expects a Queryset or a List from as a route function result.</p> <p>This feature was inspired by the DRF OrderingFilter</p>"},{"location":"tutorial/ordering/#properties","title":"Properties","text":"<p><code>def ordering(func_or_ordering_class: Any = NOT_SET, **ordering_params: Any) -&gt; Callable[..., Any]:</code></p> <ul> <li>func_or_ordering_class: Defines a route function or an Ordering Class. default: <code>ninja_extra.ordering.Ordering</code></li> <li>ordering_params: extra parameters for initialising Ordering Class</li> </ul>"},{"location":"tutorial/ordering/#changing-default-ordering-class","title":"Changing Default Ordering Class","text":"<p>To change the default ordering class, you need to add a <code>NINJA_EXTRA</code> variable in <code>settings.py</code> with a key <code>ORDERING_CLASS</code> and value defining path to ordering class</p> <pre><code># Django project settings.py\nINSTALLED_APPS = [\n    ...\n]\nNINJA_EXTRA={\n    'ORDERING_CLASS': 'someapp.somemodule.CustomOrdering'\n}\n</code></pre>"},{"location":"tutorial/ordering/#usage","title":"Usage","text":"<ul> <li>If you do not specify the <code>ordering_fields</code> parameter, all fields from the QuerySet will be used for ordering.</li> <li>For example, to order users by username: <p>http://example.com/api/users?ordering=username</p> </li> <li>The client may also specify reverse orderings by prefixing the field name with '-', example: <p>http://example.com/api/users?ordering=-username</p> </li> <li>Multiple orderings may also be specified: <p>http://example.com/api/users?ordering=username,email</p> </li> </ul> <pre><code>from typing import List\nfrom ninja_extra.ordering import ordering, Ordering\nfrom ninja_extra import api_controller, route, NinjaExtraAPI\nfrom ninja import ModelSchema\nfrom django.contrib.auth import get_user_model\n\nuser_model = get_user_model()\n\n\nclass UserSchema(ModelSchema):\n    class Config:\n        model = user_model\n        model_fields = ['username', 'email']\n\n\n@api_controller('/users')\nclass UserController:\n    @route.get('', response=List[UserSchema])\n    @ordering(Ordering, ordering_fields=['username', 'email'])\n    def get_users(self):\n        return user_model.objects.all()\n\n    @route.get('/all-sort', response=List[UserSchema])\n    @ordering\n    def get_users_with_all_field_ordering(self):\n        return [u for u in user_model.objects.all()]\n\n\napi = NinjaExtraAPI(title='Ordering Test')\napi.register_controllers(UserController)\n</code></pre>"},{"location":"tutorial/ordering/#note","title":"Note","text":"<p>If you use the <code>paginate</code> decorator and the <code>ordering</code> decorator together, the <code>paginate</code> decorator should be above the <code>ordering</code> decorator because first the data are sorted and then the data are paginated, for example:</p> <pre><code>   @route.get('', response=List[UserSchema])\n   @paginate\n   @ordering(Ordering, ordering_fields=['username', 'email'])\n   def get_users(self):\n       return user_model.objects.all()\n</code></pre>"},{"location":"tutorial/pagination/","title":"Pagination","text":"<p>Django Ninja Extra provides an intuitive pagination model using <code>paginate</code> decoration from the Django-Ninja-Extra pagination module. It expects a List or Queryset from as a route function result.</p>"},{"location":"tutorial/pagination/#properties","title":"Properties","text":"<p><code>def paginate(func_or_pgn_class: Any = NOT_SET, **paginator_params: Any) -&gt; Callable[..., Any]:</code></p> <ul> <li>func_or_pgn_class: Defines a route function or a Pagination Class. default: <code>ninja_extra.pagination.LimitOffsetPagination</code></li> <li>paginator_params: extra parameters for initialising Pagination Class</li> </ul>"},{"location":"tutorial/pagination/#using-ninja-limitoffsetpagination","title":"Using Ninja LimitOffsetPagination","text":"<p>When using <code>ninja_extra.pagination.LimitOffsetPagination</code>, you should use <code>NinjaPaginationResponseSchema</code> as pagination response schema wrapper. For example:  <pre><code>from ninja_extra.schemas import NinjaPaginationResponseSchema\n\n...\n\n@route.get('', response=NinjaPaginationResponseSchema[UserSchema])\n@paginate()\ndef list_items(self):\n    return item_model.objects.all()\n</code></pre></p>"},{"location":"tutorial/pagination/#changing-default-pagination-class","title":"Changing Default Pagination Class","text":"<p>To change the default pagination class, you need to add a <code>NINJA_EXTRA</code> variable in <code>settings.py</code> with a key <code>PAGINATION_CLASS</code> and value defining path to pagination class <pre><code># Django project settings.py\nINSTALLED_APPS = [\n    ...\n]\nNINJA_EXTRA={\n    'PAGINATION_CLASS': 'ninja_extra.pagination.PageNumberPaginationExtra'\n}\n</code></pre></p>"},{"location":"tutorial/pagination/#usage","title":"Usage","text":"<pre><code>from typing import List\nfrom ninja_extra.pagination import (\n    paginate, PageNumberPaginationExtra, PaginatedResponseSchema\n)\nfrom ninja_extra import api_controller, route, NinjaExtraAPI\nfrom ninja import ModelSchema\nfrom django.contrib.auth import get_user_model\n\nuser_model = get_user_model()\n\n\nclass UserSchema(ModelSchema):\n    class Config:\n        model = user_model\n        model_fields = ['username', 'email']\n\n\n@api_controller('/users')\nclass UserController:\n    @route.get('', response=PaginatedResponseSchema[UserSchema])\n    @paginate(PageNumberPaginationExtra, page_size=50)\n    def get_users(self):\n        return user_model.objects.all()\n\n    @route.get('/limit', response=List[UserSchema])\n    @paginate\n    def get_users_with_limit(self):\n        # this will use default paginator class - ninja_extra.pagination.LimitOffsetPagination\n        return user_model.objects.all()\n\n\napi = NinjaExtraAPI(title='Pagination Test')\napi.register_controllers(UserController)\n</code></pre>"},{"location":"tutorial/path/","title":"Path Parameter","text":"<p>Route path parameters are declared in python format-strings. for example:</p> <pre><code>from ninja_extra import api_controller, route\nfrom ninja import constants\n\n\n@api_controller('', tags=['My Operations'], auth=constants.NOT_SET, permissions=[])\nclass MyAPIController:\n    @route.get('/users/{user_id}')\n    def get_user_by_id(self, user_id: int):\n        return {'user_id': user_id}\n</code></pre> <p>The value of the path parameter <code>user_id</code> will be passed to your function as the argument <code>user_id</code>.</p> <p>Info</p> <p>Read more</p>"},{"location":"tutorial/query/","title":"Query Request","text":"<p>Django-Ninja assumes function parameters that are not among path parameters as query parameters.</p> <p>For example:</p> <pre><code>from ninja import constants\nfrom ninja_extra import api_controller, route\n\n\n@api_controller('', tags=['My Operations'], auth=constants.NOT_SET, permissions=[])\nclass MyAPIController:\n    weapons = [\"Ninjato\", \"Shuriken\", \"Katana\", \"Kama\", \"Kunai\", \"Naginata\", \"Yari\"]\n\n    @route.get(\"/weapons\")\n    def list_weapons(self, limit: int = 10, offset: int = 0):\n        return self.weapons[offset: offset + limit]\n</code></pre> <p>To query this operation, you use a URL like: <pre><code>    http://localhost:8000/api/weapons?offset=0&amp;limit=10\n</code></pre></p> <p>Info</p> <p>Read more</p>"},{"location":"tutorial/schema/","title":"Schema","text":"<p>Django-Ninja Pydantic integration is one of the best features of Django-Ninja.  With Pydantic, you can validate the inflow and outflow of data from your API, and It's very fast. Making a partial replacement of DRF serializers</p> <p>But if you want complete DRF Serializer replacement then Ninja-Schema is what you need.</p>"},{"location":"tutorial/schema/#ninja-schema","title":"Ninja Schema","text":"<p>Ninja Schema converts your Django ORM models to Pydantic schemas with more Pydantic features supported.</p> <p>Inspired by: django-ninja and djantic</p> <p>Key features:</p> <ul> <li>Custom Field Support: Ninja Schema converts django model to native pydantic types which gives you quick field validation out of the box. eg Enums, email, IPAddress, URLs, JSON, etc</li> <li>Field Validator: Fields can be validated with model_validator just like pydantic validator or root_validator. </li> </ul> <p>Info</p> <p>Visit Ninja Schema for More information</p>"},{"location":"tutorial/schema/#accessing-request-object-in-schema","title":"Accessing Request Object in Schema","text":"<p>Django Ninja Extra provides <code>RouteContext</code> object which available during request lifecycle. The <code>RouteContext</code> holds</p>"},{"location":"tutorial/searching/","title":"Searching","text":"<p>Django Ninja Extra provides an intuitive searching model using <code>searching</code> decoration from the Django-Ninja-Extra searching module. It expects a Queryset or a List from as a route function result.</p> <p>This feature was inspired by the DRF SearchFilter</p>"},{"location":"tutorial/searching/#properties","title":"Properties","text":"<p><code>def searching(func_or_searching_class: Any = NOT_SET, **searching_params: Any) -&gt; Callable[..., Any]:</code></p> <ul> <li>func_or_searching_class: Defines a route function or an Searching Class. default: <code>ninja_extra.searching.Searching</code></li> <li>searching_params: extra parameters for initialising Searching Class</li> </ul>"},{"location":"tutorial/searching/#changing-default-searching-class","title":"Changing Default Searching Class","text":"<p>To change the default searching class, you need to add a <code>NINJA_EXTRA</code> variable in <code>settings.py</code> with a key <code>SEARCHING_CLASS</code> and value defining path to searching class</p> <pre><code># Django project settings.py\nINSTALLED_APPS = [\n    ...\n]\nNINJA_EXTRA={\n    'SEARCHING_CLASS': 'someapp.somemodule.CustomSearching'\n}\n</code></pre>"},{"location":"tutorial/searching/#usage","title":"Usage","text":"<ul> <li>If you do not specify the <code>search_fields</code> parameter, will return the result without change.</li> <li>For example, to search users by username or email: <p>http://example.com/api/users?search=someuser</p> </li> <li>You can also perform a related lookup on a ForeignKey or ManyToManyField with the lookup API double-underscore notation: <p>search_fields = ['username', 'email', 'profile__profession']</p> </li> <li> <p>By default, searches will use case-insensitive partial matches.  The search parameter may contain multiple search terms, which should be whitespace and/or comma separated.  If multiple search terms are used then objects will be returned in the list only if all the provided terms are matched. The search behavior may be restricted by prepending various characters to the <code>search_fields</code>.</p> </li> <li> <p>'^' Starts-with search.</p> </li> <li>'=' Exact matches.</li> <li>'@' Full-text search.  (Currently only supported Django's PostgreSQL backend.)</li> <li>'$' Regex search.</li> </ul> <p>For example:</p> <pre><code>&gt; search_fields = ['=username', '=email']\n</code></pre> <pre><code>from typing import List\nfrom ninja_extra.searching import searching, Searching\nfrom ninja_extra import api_controller, route, NinjaExtraAPI\nfrom ninja import ModelSchema\nfrom django.contrib.auth import get_user_model\n\nuser_model = get_user_model()\n\n\nclass UserSchema(ModelSchema):\n    class Config:\n        model = user_model\n        model_fields = ['username', 'email']\n\n\n@api_controller('/users')\nclass UserController:\n    @route.get('', response=List[UserSchema])\n    @searching(Searching, search_fields=['username', 'email'])\n    def get_users(self):\n        return user_model.objects.all()\n\n    @route.get('/iexact-email', response=List[UserSchema])\n    @searching(search_fields=['=email'])\n    def get_users_with_search_iexact_email(self):\n        return [u for u in user_model.objects.all()]\n\n\napi = NinjaExtraAPI(title='Searching Test')\napi.register_controllers(UserController)\n</code></pre>"},{"location":"tutorial/searching/#note","title":"Note","text":"<p>If you use the <code>paginate</code> decorator, the <code>ordering</code> decorator and the <code>searching</code> decorator together, the <code>paginate</code> decorator should be above the <code>ordering</code> decorator and the <code>ordering</code> decorator should be above the <code>searching</code> decorator because first the data is filtered, then the data is sorted and then paginated:, for example:</p> <pre><code>   @route.get('', response=List[UserSchema])\n   @paginate\n   @ordering(Ordering, ordering_fields=['username', 'email'])\n   @searching(Searching, search_fields=['username', 'email'])\n   def get_users(self):\n       return user_model.objects.all()\n</code></pre>"},{"location":"tutorial/testing/","title":"Testing APIController","text":"<p>Django Ninja Extra has a TestClient that provides seamless testing of <code>ControllerBase</code> classes with <code>pytest</code></p> <p>There are two test clients</p> <ul> <li><code>TestClient</code>: for synchronous route functions</li> <li><code>TestAsyncClient</code>: for asynchronous route functions</li> </ul> <p>Both <code>TestClient</code> and <code>TestAsyncClient</code> inherit from the Django Ninja <code>TestClient</code> class which provides the base functionality  for making requests to the application, and both of them also have similar methods such as <code>get</code>, <code>post</code>, <code>put</code>, <code>patch</code>, <code>delete</code>,  and <code>options</code> for making requests to the application.</p> <p>For example, to test a GET request to the <code>/users</code> endpoint, you can use the TestClient as follows:</p> <p><pre><code>import pytest\nfrom .controllers import UserController\nfrom ninja_extra.testing import TestClient\n\n\n@pytest.mark.django_db\nclass TestMyMathController:\n    def test_get_users(self):\n        client = TestClient(UserController)\n        response = client.get('/users')\n        assert response.status_code == 200\n        assert response.json()[0] == {\n            'first_name': 'Ninja Extra',\n            'username': 'django_ninja',\n            'email': 'john.doe@gmail.com'\n        }\n</code></pre> Similarly, for testing an asynchronous route function, you can use TestClientAsync as follows:</p> <pre><code>from ninja_extra import api_controller, route\nfrom ninja_extra.testing import TestAsyncClient\n\n\n@api_controller('', tags=['Math'])\nclass MyMathController:\n    @route.get('/add',)\n    async def add(self, a: int, b: int):\n        \"\"\"add a to b\"\"\"\n        return {\"result\": a - b}\n\n\nclass TestMyMathController:\n    def test_get_users_async(self):\n        client = TestAsyncClient(MyMathController)\n        response = client.get('/add', query=dict(a=3, b=5))\n        assert response.status_code == 200\n        assert response.json() == {\"result\": -2}\n</code></pre>"},{"location":"tutorial/throttling/","title":"Throttling","text":"<p>Throttling can be seen as a permission that determines if a request should be authorized.  It indicates a temporary state used to control the rate of requests that clients can make to an API.</p> <pre><code>from ninja_extra import NinjaExtraAPI\nfrom ninja_extra.throttling import UserRateThrottle, AnonRateThrottle\napi = NinjaExtraAPI()\n\n@api.get('/users', throttle=[AnonRateThrottle(), UserRateThrottle()])\ndef my_throttled_endpoint(request):\n    return 'foo'\n</code></pre> <p>Info</p> <p>The above example won't be throttled because the default scope for <code>UserRateThrottle</code> and <code>AnonRateThrottle</code> is <code>none</code></p>"},{"location":"tutorial/throttling/#multiple-throttling","title":"Multiple Throttling","text":"<p>Django-ninja-extra throttle supposes multiple throttles which is useful to impose different constraints, which could be burst throttling rate or sustained throttling rates, on an API. for example, you might want to limit a user to a maximum of 60 requests per minute, and 1000 requests per day.</p> <pre><code>from ninja_extra import NinjaExtraAPI\nfrom ninja_extra.throttling import UserRateThrottle\napi = NinjaExtraAPI()\n\nclass User60MinRateThrottle(UserRateThrottle):\n    rate = \"60/min\"\n    scope = \"minutes\"\n\n\nclass User1000PerDayRateThrottle(UserRateThrottle):\n    rate = \"1000/day\"\n    scope = \"days\"\n\n@api.get('/users', throttle=[User60MinRateThrottle(), User1000PerDayRateThrottle()])\ndef my_throttled_endpoint(request):\n    return 'foo'\n</code></pre>"},{"location":"tutorial/throttling/#throttling-policy-settings","title":"Throttling Policy Settings","text":"<p>You can set globally default throttling classes and rates in your project <code>settings.py</code> by overriding the keys below: <pre><code># django settings.py\nNINJA_EXTRA = {\n    'THROTTLE_RATES': {\n        'user': '1000/day',\n        'anon': '100/day',\n    },\n    'NUM_PROXIES': None\n}\n</code></pre> The rate descriptions used in <code>THROTTLE_RATES</code> may include <code>second</code>, <code>minute</code>, <code>hour</code> or <code>day</code> as the throttle period.</p> <pre><code>from ninja_extra import NinjaExtraAPI\nfrom ninja_extra.throttling import UserRateThrottle\n\napi = NinjaExtraAPI()\n\n@api.get('/users', throttle=UserRateThrottle())\ndef my_throttled_endpoint(request):\n    return 'foo'\n</code></pre>"},{"location":"tutorial/throttling/#clients-identification","title":"Clients Identification","text":"<p>Clients are identified by x-Forwarded-For in HTTP header and REMOTE_ADDR from WSGI variable. These are unique identities which identifies clients IP addresses used for throttling. <code>X-Forwarded-For</code> is preferable over <code>REMOTE_ADDR</code> and is used as so.</p>"},{"location":"tutorial/throttling/#limit-clients-proxies","title":"Limit Clients Proxies","text":"<p>If you need to strictly identify unique client IP addresses, you'll need to first configure the number of application proxies that the API runs behind by setting the <code>NUM_PROXIES</code> setting. This setting should be an integer of zero or more. If set to non-zero then the client IP will be identified as being the last IP address in the X-Forwarded-For header, once any application proxy IP addresses have first been excluded. If set to zero, then the REMOTE_ADDR value will always be used as the identifying IP address. It is important to understand that if you configure the <code>NUM_PROXIES</code> setting, then all clients behind a unique NAT'd gateway will be treated as a single client.</p> <p>Info</p> <p>Further context on how the X-Forwarded-For header works, and identifying a remote client IP can be found here.</p>"},{"location":"tutorial/throttling/#throttling-model-cache-setup","title":"Throttling Model Cache setup","text":"<p>The throttling models used in django-ninja-extra utilizes Django cache backend. It uses the <code>default</code> value of <code>LocMemCache</code> See Django's cache documentation for more details.</p> <p>If you dont want to use the default cache defined in throttle model, here is an example on how to define a different cache for a throttling model <pre><code>from django.core.cache import caches\nfrom ninja_extra.throttling import AnonRateThrottle\n\n\nclass CustomAnonRateThrottle(AnonRateThrottle):\n    cache = caches['alternate']\n</code></pre></p>"},{"location":"tutorial/throttling/#api-reference","title":"API Reference","text":""},{"location":"tutorial/throttling/#anonratethrottle","title":"AnonRateThrottle","text":"<p><code>AnonRateThrottle</code> model is for throttling unauthenticated users using their IP address as key to throttle against. It is suitable for restricting rate of requests from an unknown source</p> <p>Request Permission is determined by: - <code>rate</code> defined in derived class - <code>anon</code> scope defined in <code>THROTTLE_RATES</code> in <code>NINJA_EXTRA</code> settings in <code>settings.py</code> </p>"},{"location":"tutorial/throttling/#userratethrottle","title":"UserRateThrottle","text":"<p><code>UserRateThrottle</code> model is for throttling authenticated users using user id or pk to generate a key to throttle against. Unauthenticated requests will fall back to using the IP address of the incoming request to generate a unique key to throttle against.</p> <p>Request Permission is determined by: - <code>rate</code> defined in derived class - <code>user</code> scope defined in <code>THROTTLE_RATES</code> in <code>NINJA_EXTRA</code> settings in <code>settings.py</code> </p> <p>You can use multiple user throttle rates for a <code>UserRateThrottle</code> model, for example: <pre><code># example/throttles.py\nfrom ninja_extra.throttling import UserRateThrottle\n\n\nclass BurstRateThrottle(UserRateThrottle):\n    scope = 'burst'\n\n\nclass SustainedRateThrottle(UserRateThrottle):\n    scope = 'sustained'\n</code></pre></p> <pre><code># django settings.py\nNINJA_EXTRA = {\n    'THROTTLE_RATES': {\n        'burst': '60/min',\n        'sustained': '1000/day'\n    }\n}\n</code></pre>"},{"location":"tutorial/throttling/#dynamicratethrottle","title":"DynamicRateThrottle","text":"<p><code>DynamicRateThrottle</code> model is for throttling authenticated and unauthenticated users in similar way as <code>UserRateThrottle</code>.  Its key feature is in the ability to dynamically set <code>scope</code> where its used. for an example: we can defined a scope in settings</p> <pre><code># django settings.py\nNINJA_EXTRA = {\n    'THROTTLE_RATES': {\n        'burst': '60/min',\n        'sustained': '1000/day'\n    }\n}\n</code></pre> <p><pre><code># api.py\nfrom ninja_extra import NinjaExtraAPI\nfrom ninja_extra.throttling import DynamicRateThrottle\napi = NinjaExtraAPI()\n\n@api.get('/users', throttle=DynamicRateThrottle(scope='burst'))\ndef get_users(request):\n    return 'foo'\n\n@api.get('/users/&lt;int:id&gt;', throttle=DynamicRateThrottle(scope='sustained'))\ndef get_user_by_id(request, id: int):\n    return 'foo'\n</code></pre> Here, we dynamically applied <code>sustained</code> rates and <code>burst</code> rates to <code>get_users</code> and <code>get_user_by_id</code> respectively</p> <p>new in v0.15.8</p> <p>You can throttle all controller endpoints actions at the controller class level</p>"},{"location":"tutorial/throttling/#controller-throttling","title":"Controller Throttling","text":"<pre><code># api.py\nfrom ninja_extra import (\n    NinjaExtraAPI, api_controller, ControllerBase,\n    http_get\n)\nfrom ninja_extra.throttling import DynamicRateThrottle\napi = NinjaExtraAPI()\n\n@api_controller(\"/throttled-controller\", throttle=[DynamicRateThrottle(scope=\"sustained\")])\nclass ThrottlingControllerSample(ControllerBase):\n    @http_get(\"/endpoint_1\", throttle=DynamicRateThrottle(scope=\"burst\"))\n    def endpoint_1(self, request):\n        # this will override the generally throttling applied at the controller\n        return \"foo\"\n\n    @http_get(\"/endpoint_2\")\n    def endpoint_2(self, request):\n        return \"foo\"\n\n    @http_get(\"/endpoint_3\")\n    def endpoint_3(self, request):\n        return \"foo\"\n\n\napi.register_controllers(ThrottlingControllerSample)\n</code></pre>"},{"location":"tutorial/versioning/","title":"Versioning","text":""},{"location":"tutorial/versioning/#different-api-version-numbers","title":"Different API version numbers","text":"<p>With Django Ninja Extra, it's very much easy to run multiple API versions from a single Django project.</p> <p>All you have to do is create two or more NinjaAPI instances with different <code>version</code> arguments:</p> <p><code>api_v1.py</code>:</p> <pre><code>from ninja_extra import NinjaExtraAPI, route, api_controller\n\n@api_controller\nclass MyV1Controller:\n    @route.get('/hello')\n    def hello(self):\n        return {'message': 'Hello from V1'}\n\n    @route.get('/example')\n    def example(self):\n        return {'message': 'Hello from V1 Example'}\n\n\napi = NinjaExtraAPI(version='1.0.0')\napi.register_controllers(MyV1Controller)\n</code></pre> <p>api_v2.py: You can reuse your APIControllers and make modifications to specific routes.</p> <pre><code>from ninja_extra import NinjaExtraAPI, route, api_controller\nfrom .api_v1 import MyV1Controller\n\n@api_controller\nclass MyV2Controller(MyV1Controller):\n    @route.get('/example')\n    def example(self):\n        return {'message': 'Hello from V2 Example'}\n\n\napi = NinjaExtraAPI(version='2.0.0')\napi.register_controllers(MyV2Controller)\n</code></pre> <p>and then in urls.py:</p> <pre><code>...\nfrom api_v1 import api as api_v1\nfrom api_v2 import api as api_v2\n\n\nurlpatterns = [\n    ...\n    path('api/v1/', api_v1.urls),\n    path('api/v2/', api_v2.urls),\n]\n</code></pre> <p>Now you can go to different OpenAPI docs pages for each version:</p> <ul> <li>http://127.0.0.1/api/v1/docs</li> <li>http://127.0.0.1/api/v2/docs</li> </ul>"},{"location":"tutorial/versioning/#different-business-logic","title":"Different business logic","text":"<p>In the same way, you can define a different API for different components or areas:</p> <pre><code>...\n\n\napi = NinjaExtraAPI(auth=token_auth, urls_namespace='public_api')\n...\n\napi_private = NinjaExtraAPI(auth=session_auth, urls_namespace='private_api')\n...\n\n\nurlpatterns = [\n    ...\n    path('api/', api.urls),\n    path('internal-api/', api_private.urls),\n]\n</code></pre> <p>Note</p> <p>If you use different NinjaExtraAPI instances, you need to define different <code>version</code>s or different <code>urls_namespace</code>s. This is the same with NinjaAPI instances</p>"}]}